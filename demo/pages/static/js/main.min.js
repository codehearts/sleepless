/*
    json2.js
    2011-10-19

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    See http://www.JSON.org/js.html


    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.


    This file creates a global JSON object containing two methods: stringify
    and parse.

        JSON.stringify(value, replacer, space)
            value       any JavaScript value, usually an object or array.

            replacer    an optional parameter that determines how object
                        values are stringified for objects. It can be a
                        function or an array of strings.

            space       an optional parameter that specifies the indentation
                        of nested structures. If it is omitted, the text will
                        be packed without extra whitespace. If it is a number,
                        it will specify the number of spaces to indent at each
                        level. If it is a string (such as '\t' or '&nbsp;'),
                        it contains the characters used to indent at each level.

            This method produces a JSON text from a JavaScript value.

            When an object value is found, if the object contains a toJSON
            method, its toJSON method will be called and the result will be
            stringified. A toJSON method does not serialize: it returns the
            value represented by the name/value pair that should be serialized,
            or undefined if nothing should be serialized. The toJSON method
            will be passed the key associated with the value, and this will be
            bound to the value

            For example, this would serialize Dates as ISO strings.

                Date.prototype.toJSON = function (key) {
                    function f(n) {
                        // Format integers to have at least two digits.
                        return n < 10 ? '0' + n : n;
                    }

                    return this.getUTCFullYear()   + '-' +
                         f(this.getUTCMonth() + 1) + '-' +
                         f(this.getUTCDate())      + 'T' +
                         f(this.getUTCHours())     + ':' +
                         f(this.getUTCMinutes())   + ':' +
                         f(this.getUTCSeconds())   + 'Z';
                };

            You can provide an optional replacer method. It will be passed the
            key and value of each member, with this bound to the containing
            object. The value that is returned from your method will be
            serialized. If your method returns undefined, then the member will
            be excluded from the serialization.

            If the replacer parameter is an array of strings, then it will be
            used to select the members to be serialized. It filters the results
            such that only members with keys listed in the replacer array are
            stringified.

            Values that do not have JSON representations, such as undefined or
            functions, will not be serialized. Such values in objects will be
            dropped; in arrays they will be replaced with null. You can use
            a replacer function to replace those with JSON values.
            JSON.stringify(undefined) returns undefined.

            The optional space parameter produces a stringification of the
            value that is filled with line breaks and indentation to make it
            easier to read.

            If the space parameter is a non-empty string, then that string will
            be used for indentation. If the space parameter is a number, then
            the indentation will be that many spaces.

            Example:

            text = JSON.stringify(['e', {pluribus: 'unum'}]);
            // text is '["e",{"pluribus":"unum"}]'


            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

            text = JSON.stringify([new Date()], function (key, value) {
                return this[key] instanceof Date ?
                    'Date(' + this[key] + ')' : value;
            });
            // text is '["Date(---current time---)"]'


        JSON.parse(text, reviver)
            This method parses a JSON text to produce an object or array.
            It can throw a SyntaxError exception.

            The optional reviver parameter is a function that can filter and
            transform the results. It receives each of the keys and values,
            and its return value is used instead of the original value.
            If it returns what it received, then the structure is not modified.
            If it returns undefined then the member is deleted.

            Example:

            // Parse the text. Values that look like ISO date strings will
            // be converted to Date objects.

            myData = JSON.parse(text, function (key, value) {
                var a;
                if (typeof value === 'string') {
                    a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                    if (a) {
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                            +a[5], +a[6]));
                    }
                }
                return value;
            });

            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
                var d;
                if (typeof value === 'string' &&
                        value.slice(0, 5) === 'Date(' &&
                        value.slice(-1) === ')') {
                    d = new Date(value.slice(5, -1));
                    if (d) {
                        return d;
                    }
                }
                return value;
            });


    This is a reference implementation. You are free to copy, modify, or
    redistribute.
*/

/*jslint evil: true, regexp: true */

/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/


// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

var JSON;
if (!JSON) {
    JSON = {};
}

(function () {
    'use strict';

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function (key) {

            return isFinite(this.valueOf())
                ? this.getUTCFullYear()     + '-' +
                    f(this.getUTCMonth() + 1) + '-' +
                    f(this.getUTCDate())      + 'T' +
                    f(this.getUTCHours())     + ':' +
                    f(this.getUTCMinutes())   + ':' +
                    f(this.getUTCSeconds())   + 'Z'
                : null;
        };

        String.prototype.toJSON      =
            Number.prototype.toJSON  =
            Boolean.prototype.toJSON = function (key) {
                return this.valueOf();
            };
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string'
                ? c
                : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0
                    ? '[]'
                    : gap
                    ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']'
                    : '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === 'string') {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0
                ? '{}'
                : gap
                ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}'
                : '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== 'function') {
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                    typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== 'function') {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/
                    .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                        .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                        .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function'
                    ? walk({'': j}, '')
                    : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('JSON.parse');
        };
    }
}());


/*********************************************** 
     Begin amplify.store.min.js 
***********************************************/ 

/*!
 * Amplify Store - Persistent Client-Side Storage 1.1.0
 * 
 * Copyright 2011 appendTo LLC. (http://appendto.com/team)
 * Dual licensed under the MIT or GPL licenses.
 * http://appendto.com/open-source-licenses
 * 
 * http://amplifyjs.com
 */
(function(a,b){function e(a,e){c.addType(a,function(f,g,h){var i,j,k,l,m=g,n=(new Date).getTime();if(!f){m={},l=[],k=0;try{f=e.length;while(f=e.key(k++))d.test(f)&&(j=JSON.parse(e.getItem(f)),j.expires&&j.expires<=n?l.push(f):m[f.replace(d,"")]=j.data);while(f=l.pop())e.removeItem(f)}catch(o){}return m}f="__amplify__"+f;if(g===b){i=e.getItem(f),j=i?JSON.parse(i):{expires:-1};if(j.expires&&j.expires<=n)e.removeItem(f);else return j.data}else if(g===null)e.removeItem(f);else{j=JSON.stringify({data:g,expires:h.expires?n+h.expires:null});try{e.setItem(f,j)}catch(o){c[a]();try{e.setItem(f,j)}catch(o){throw c.error()}}}return m})}var c=a.store=function(a,b,d,e){var e=c.type;d&&d.type&&d.type in c.types&&(e=d.type);return c.types[e](a,b,d||{})};c.types={},c.type=null,c.addType=function(a,b){c.type||(c.type=a),c.types[a]=b,c[a]=function(b,d,e){e=e||{},e.type=a;return c(b,d,e)}},c.error=function(){return"amplify.store quota exceeded"};var d=/^__amplify__/;for(var f in{localStorage:1,sessionStorage:1})try{window[f].getItem&&e(f,window[f])}catch(g){}if(window.globalStorage)try{e("globalStorage",window.globalStorage[window.location.hostname]),c.type==="sessionStorage"&&(c.type="globalStorage")}catch(g){}(function(){if(!c.types.localStorage){var a=document.createElement("div"),d="amplify";a.style.display="none",document.getElementsByTagName("head")[0].appendChild(a);try{a.addBehavior("#default#userdata"),a.load(d)}catch(e){a.parentNode.removeChild(a);return}c.addType("userData",function(e,f,g){a.load(d);var h,i,j,k,l,m=f,n=(new Date).getTime();if(!e){m={},l=[],k=0;while(h=a.XMLDocument.documentElement.attributes[k++])i=JSON.parse(h.value),i.expires&&i.expires<=n?l.push(h.name):m[h.name]=i.data;while(e=l.pop())a.removeAttribute(e);a.save(d);return m}e=e.replace(/[^-._0-9A-Za-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u37f-\u1fff\u200c-\u200d\u203f\u2040\u2070-\u218f]/g,"-");if(f===b){h=a.getAttribute(e),i=h?JSON.parse(h):{expires:-1};if(i.expires&&i.expires<=n)a.removeAttribute(e);else return i.data}else f===null?a.removeAttribute(e):(j=a.getAttribute(e),i=JSON.stringify({data:f,expires:g.expires?n+g.expires:null}),a.setAttribute(e,i));try{a.save(d)}catch(o){j===null?a.removeAttribute(e):a.setAttribute(e,j),c.userData();try{a.setAttribute(e,i),a.save(d)}catch(o){j===null?a.removeAttribute(e):a.setAttribute(e,j);throw c.error()}}return m})}})(),function(){function e(a){return a===b?b:JSON.parse(JSON.stringify(a))}var a={},d={};c.addType("memory",function(c,f,g){if(!c)return e(a);if(f===b)return e(a[c]);d[c]&&(clearTimeout(d[c]),delete d[c]);if(f===null){delete a[c];return null}a[c]=f,g.expires&&(d[c]=setTimeout(function(){delete a[c],delete d[c]},g.expires));return f})}()})(this.amplify=this.amplify||{})

/*********************************************** 
     Begin jquery.history.js 
***********************************************/ 

window.JSON||(window.JSON={}),function(){function f(a){return a<10?"0"+a:a}function quote(a){return escapable.lastIndex=0,escapable.test(a)?'"'+a.replace(escapable,function(a){var b=meta[a];return typeof b=="string"?b:"\\u"+("0000"+a.charCodeAt(0).toString(16)).slice(-4)})+'"':'"'+a+'"'}function str(a,b){var c,d,e,f,g=gap,h,i=b[a];i&&typeof i=="object"&&typeof i.toJSON=="function"&&(i=i.toJSON(a)),typeof rep=="function"&&(i=rep.call(b,a,i));switch(typeof i){case"string":return quote(i);case"number":return isFinite(i)?String(i):"null";case"boolean":case"null":return String(i);case"object":if(!i)return"null";gap+=indent,h=[];if(Object.prototype.toString.apply(i)==="[object Array]"){f=i.length;for(c=0;c<f;c+=1)h[c]=str(c,i)||"null";return e=h.length===0?"[]":gap?"[\n"+gap+h.join(",\n"+gap)+"\n"+g+"]":"["+h.join(",")+"]",gap=g,e}if(rep&&typeof rep=="object"){f=rep.length;for(c=0;c<f;c+=1)d=rep[c],typeof d=="string"&&(e=str(d,i),e&&h.push(quote(d)+(gap?": ":":")+e))}else for(d in i)Object.hasOwnProperty.call(i,d)&&(e=str(d,i),e&&h.push(quote(d)+(gap?": ":":")+e));return e=h.length===0?"{}":gap?"{\n"+gap+h.join(",\n"+gap)+"\n"+g+"}":"{"+h.join(",")+"}",gap=g,e}}"use strict",typeof Date.prototype.toJSON!="function"&&(Date.prototype.toJSON=function(a){return isFinite(this.valueOf())?this.getUTCFullYear()+"-"+f(this.getUTCMonth()+1)+"-"+f(this.getUTCDate())+"T"+f(this.getUTCHours())+":"+f(this.getUTCMinutes())+":"+f(this.getUTCSeconds())+"Z":null},String.prototype.toJSON=Number.prototype.toJSON=Boolean.prototype.toJSON=function(a){return this.valueOf()});var JSON=window.JSON,cx=/[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,escapable=/[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,gap,indent,meta={"\b":"\\b","\t":"\\t","\n":"\\n","\f":"\\f","\r":"\\r",'"':'\\"',"\\":"\\\\"},rep;typeof JSON.stringify!="function"&&(JSON.stringify=function(a,b,c){var d;gap="",indent="";if(typeof c=="number")for(d=0;d<c;d+=1)indent+=" ";else typeof c=="string"&&(indent=c);rep=b;if(!b||typeof b=="function"||typeof b=="object"&&typeof b.length=="number")return str("",{"":a});throw new Error("JSON.stringify")}),typeof JSON.parse!="function"&&(JSON.parse=function(text,reviver){function walk(a,b){var c,d,e=a[b];if(e&&typeof e=="object")for(c in e)Object.hasOwnProperty.call(e,c)&&(d=walk(e,c),d!==undefined?e[c]=d:delete e[c]);return reviver.call(a,b,e)}var j;text=String(text),cx.lastIndex=0,cx.test(text)&&(text=text.replace(cx,function(a){return"\\u"+("0000"+a.charCodeAt(0).toString(16)).slice(-4)}));if(/^[\],:{}\s]*$/.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,"@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,"]").replace(/(?:^|:|,)(?:\s*\[)+/g,"")))return j=eval("("+text+")"),typeof reviver=="function"?walk({"":j},""):j;throw new SyntaxError("JSON.parse")})}(),function(a,b){"use strict";var c=a.History=a.History||{},d=a.jQuery;if(typeof c.Adapter!="undefined")throw new Error("History.js Adapter has already been loaded...");c.Adapter={bind:function(a,b,c){d(a).bind(b,c)},trigger:function(a,b,c){d(a).trigger(b,c)},extractEventData:function(a,c,d){var e=c&&c.originalEvent&&c.originalEvent[a]||d&&d[a]||b;return e},onDomLoad:function(a){d(a)}},typeof c.init!="undefined"&&c.init()}(window),function(a,b){"use strict";var c=a.document,d=a.setTimeout||d,e=a.clearTimeout||e,f=a.setInterval||f,g=a.History=a.History||{};if(typeof g.initHtml4!="undefined")throw new Error("History.js HTML4 Support has already been loaded...");g.initHtml4=function(){if(typeof g.initHtml4.initialized!="undefined")return!1;g.initHtml4.initialized=!0,g.enabled=!0,g.savedHashes=[],g.isLastHash=function(a){var b=g.getHashByIndex(),c;return c=a===b,c},g.saveHash=function(a){return g.isLastHash(a)?!1:(g.savedHashes.push(a),!0)},g.getHashByIndex=function(a){var b=null;return typeof a=="undefined"?b=g.savedHashes[g.savedHashes.length-1]:a<0?b=g.savedHashes[g.savedHashes.length+a]:b=g.savedHashes[a],b},g.discardedHashes={},g.discardedStates={},g.discardState=function(a,b,c){var d=g.getHashByState(a),e;return e={discardedState:a,backState:c,forwardState:b},g.discardedStates[d]=e,!0},g.discardHash=function(a,b,c){var d={discardedHash:a,backState:c,forwardState:b};return g.discardedHashes[a]=d,!0},g.discardedState=function(a){var b=g.getHashByState(a),c;return c=g.discardedStates[b]||!1,c},g.discardedHash=function(a){var b=g.discardedHashes[a]||!1;return b},g.recycleState=function(a){var b=g.getHashByState(a);return g.discardedState(a)&&delete g.discardedStates[b],!0},g.emulated.hashChange&&(g.hashChangeInit=function(){g.checkerFunction=null;var b="",d,e,h,i;return g.isInternetExplorer()?(d="historyjs-iframe",e=c.createElement("iframe"),e.setAttribute("id",d),e.style.display="none",c.body.appendChild(e),e.contentWindow.document.open(),e.contentWindow.document.close(),h="",i=!1,g.checkerFunction=function(){if(i)return!1;i=!0;var c=g.getHash()||"",d=g.unescapeHash(e.contentWindow.document.location.hash)||"";return c!==b?(b=c,d!==c&&(h=d=c,e.contentWindow.document.open(),e.contentWindow.document.close(),e.contentWindow.document.location.hash=g.escapeHash(c)),g.Adapter.trigger(a,"hashchange")):d!==h&&(h=d,g.setHash(d,!1)),i=!1,!0}):g.checkerFunction=function(){var c=g.getHash();return c!==b&&(b=c,g.Adapter.trigger(a,"hashchange")),!0},g.intervalList.push(f(g.checkerFunction,g.options.hashChangeInterval)),!0},g.Adapter.onDomLoad(g.hashChangeInit)),g.emulated.pushState&&(g.onHashChange=function(b){var d=b&&b.newURL||c.location.href,e=g.getHashByUrl(d),f=null,h=null,i=null,j;return g.isLastHash(e)?(g.busy(!1),!1):(g.doubleCheckComplete(),g.saveHash(e),e&&g.isTraditionalAnchor(e)?(g.Adapter.trigger(a,"anchorchange"),g.busy(!1),!1):(f=g.extractState(g.getFullUrl(e||c.location.href,!1),!0),g.isLastSavedState(f)?(g.busy(!1),!1):(h=g.getHashByState(f),j=g.discardedState(f),j?(g.getHashByIndex(-2)===g.getHashByState(j.forwardState)?g.back(!1):g.forward(!1),!1):(g.pushState(f.data,f.title,f.url,!1),!0))))},g.Adapter.bind(a,"hashchange",g.onHashChange),g.pushState=function(b,d,e,f){if(g.getHashByUrl(e))throw new Error("History.js does not support states with fragement-identifiers (hashes/anchors).");if(f!==!1&&g.busy())return g.pushQueue({scope:g,callback:g.pushState,args:arguments,queue:f}),!1;g.busy(!0);var h=g.createStateObject(b,d,e),i=g.getHashByState(h),j=g.getState(!1),k=g.getHashByState(j),l=g.getHash();return g.storeState(h),g.expectedStateId=h.id,g.recycleState(h),g.setTitle(h),i===k?(g.busy(!1),!1):i!==l&&i!==g.getShortUrl(c.location.href)?(g.setHash(i,!1),!1):(g.saveState(h),g.Adapter.trigger(a,"statechange"),g.busy(!1),!0)},g.replaceState=function(a,b,c,d){if(g.getHashByUrl(c))throw new Error("History.js does not support states with fragement-identifiers (hashes/anchors).");if(d!==!1&&g.busy())return g.pushQueue({scope:g,callback:g.replaceState,args:arguments,queue:d}),!1;g.busy(!0);var e=g.createStateObject(a,b,c),f=g.getState(!1),h=g.getStateByIndex(-2);return g.discardState(f,e,h),g.pushState(e.data,e.title,e.url,!1),!0}),g.emulated.pushState&&g.getHash()&&!g.emulated.hashChange&&g.Adapter.onDomLoad(function(){g.Adapter.trigger(a,"hashchange")})},typeof g.init!="undefined"&&g.init()}(window),function(a,b){"use strict";var c=a.console||b,d=a.document,e=a.navigator,f=a.sessionStorage||!1,g=a.setTimeout,h=a.clearTimeout,i=a.setInterval,j=a.clearInterval,k=a.JSON,l=a.alert,m=a.History=a.History||{},n=a.history;k.stringify=k.stringify||k.encode,k.parse=k.parse||k.decode;if(typeof m.init!="undefined")throw new Error("History.js Core has already been loaded...");m.init=function(){return typeof m.Adapter=="undefined"?!1:(typeof m.initCore!="undefined"&&m.initCore(),typeof m.initHtml4!="undefined"&&m.initHtml4(),!0)},m.initCore=function(){if(typeof m.initCore.initialized!="undefined")return!1;m.initCore.initialized=!0,m.options=m.options||{},m.options.hashChangeInterval=m.options.hashChangeInterval||100,m.options.safariPollInterval=m.options.safariPollInterval||500,m.options.doubleCheckInterval=m.options.doubleCheckInterval||500,m.options.storeInterval=m.options.storeInterval||1e3,m.options.busyDelay=m.options.busyDelay||250,m.options.debug=m.options.debug||!1,m.options.initialTitle=m.options.initialTitle||d.title,m.intervalList=[],m.clearAllIntervals=function(){var a,b=m.intervalList;if(typeof b!="undefined"&&b!==null){for(a=0;a<b.length;a++)j(b[a]);m.intervalList=null}},m.debug=function(){(m.options.debug||!1)&&m.log.apply(m,arguments)},m.log=function(){var a=typeof c!="undefined"&&typeof c.log!="undefined"&&typeof c.log.apply!="undefined",b=d.getElementById("log"),e,f,g,h,i;a?(h=Array.prototype.slice.call(arguments),e=h.shift(),typeof c.debug!="undefined"?c.debug.apply(c,[e,h]):c.log.apply(c,[e,h])):e="\n"+arguments[0]+"\n";for(f=1,g=arguments.length;f<g;++f){i=arguments[f];if(typeof i=="object"&&typeof k!="undefined")try{i=k.stringify(i)}catch(j){}e+="\n"+i+"\n"}return b?(b.value+=e+"\n-----\n",b.scrollTop=b.scrollHeight-b.clientHeight):a||l(e),!0},m.getInternetExplorerMajorVersion=function(){var a=m.getInternetExplorerMajorVersion.cached=typeof m.getInternetExplorerMajorVersion.cached!="undefined"?m.getInternetExplorerMajorVersion.cached:function(){var a=3,b=d.createElement("div"),c=b.getElementsByTagName("i");while((b.innerHTML="<!--[if gt IE "+ ++a+"]><i></i><![endif]-->")&&c[0]);return a>4?a:!1}();return a},m.isInternetExplorer=function(){var a=m.isInternetExplorer.cached=typeof m.isInternetExplorer.cached!="undefined"?m.isInternetExplorer.cached:Boolean(m.getInternetExplorerMajorVersion());return a},m.emulated={pushState:!Boolean(a.history&&a.history.pushState&&a.history.replaceState&&!/ Mobile\/([1-7][a-z]|(8([abcde]|f(1[0-8]))))/i.test(e.userAgent)&&!/AppleWebKit\/5([0-2]|3[0-2])/i.test(e.userAgent)),hashChange:Boolean(!("onhashchange"in a||"onhashchange"in d)||m.isInternetExplorer()&&m.getInternetExplorerMajorVersion()<8)},m.enabled=!m.emulated.pushState,m.bugs={setHash:Boolean(!m.emulated.pushState&&e.vendor==="Apple Computer, Inc."&&/AppleWebKit\/5([0-2]|3[0-3])/.test(e.userAgent)),safariPoll:Boolean(!m.emulated.pushState&&e.vendor==="Apple Computer, Inc."&&/AppleWebKit\/5([0-2]|3[0-3])/.test(e.userAgent)),ieDoubleCheck:Boolean(m.isInternetExplorer()&&m.getInternetExplorerMajorVersion()<8),hashEscape:Boolean(m.isInternetExplorer()&&m.getInternetExplorerMajorVersion()<7)},m.isEmptyObject=function(a){for(var b in a)return!1;return!0},m.cloneObject=function(a){var b,c;return a?(b=k.stringify(a),c=k.parse(b)):c={},c},m.getRootUrl=function(){var a=d.location.protocol+"//"+(d.location.hostname||d.location.host);if(d.location.port||!1)a+=":"+d.location.port;return a+="/",a},m.getBaseHref=function(){var a=d.getElementsByTagName("base"),b=null,c="";return a.length===1&&(b=a[0],c=b.href.replace(/[^\/]+$/,"")),c=c.replace(/\/+$/,""),c&&(c+="/"),c},m.getBaseUrl=function(){var a=m.getBaseHref()||m.getBasePageUrl()||m.getRootUrl();return a},m.getPageUrl=function(){var a=m.getState(!1,!1),b=(a||{}).url||d.location.href,c;return c=b.replace(/\/+$/,"").replace(/[^\/]+$/,function(a,b,c){return/\./.test(a)?a:a+"/"}),c},m.getBasePageUrl=function(){var a=d.location.href.replace(/[#\?].*/,"").replace(/[^\/]+$/,function(a,b,c){return/[^\/]$/.test(a)?"":a}).replace(/\/+$/,"")+"/";return a},m.getFullUrl=function(a,b){var c=a,d=a.substring(0,1);return b=typeof b=="undefined"?!0:b,/[a-z]+\:\/\//.test(a)||(d==="/"?c=m.getRootUrl()+a.replace(/^\/+/,""):d==="#"?c=m.getPageUrl().replace(/#.*/,"")+a:d==="?"?c=m.getPageUrl().replace(/[\?#].*/,"")+a:b?c=m.getBaseUrl()+a.replace(/^(\.\/)+/,""):c=m.getBasePageUrl()+a.replace(/^(\.\/)+/,"")),c.replace(/\#$/,"")},m.getShortUrl=function(a){var b=a,c=m.getBaseUrl(),d=m.getRootUrl();return m.emulated.pushState&&(b=b.replace(c,"")),b=b.replace(d,"/"),m.isTraditionalAnchor(b)&&(b="./"+b),b=b.replace(/^(\.\/)+/g,"./").replace(/\#$/,""),b},m.store={},m.idToState=m.idToState||{},m.stateToId=m.stateToId||{},m.urlToId=m.urlToId||{},m.storedStates=m.storedStates||[],m.savedStates=m.savedStates||[],m.normalizeStore=function(){m.store.idToState=m.store.idToState||{},m.store.urlToId=m.store.urlToId||{},m.store.stateToId=m.store.stateToId||{}},m.getState=function(a,b){typeof a=="undefined"&&(a=!0),typeof b=="undefined"&&(b=!0);var c=m.getLastSavedState();return!c&&b&&(c=m.createStateObject()),a&&(c=m.cloneObject(c),c.url=c.cleanUrl||c.url),c},m.getIdByState=function(a){var b=m.extractId(a.url),c;if(!b){c=m.getStateString(a);if(typeof m.stateToId[c]!="undefined")b=m.stateToId[c];else if(typeof m.store.stateToId[c]!="undefined")b=m.store.stateToId[c];else{for(;;){b=(new Date).getTime()+String(Math.random()).replace(/\D/g,"");if(typeof m.idToState[b]=="undefined"&&typeof m.store.idToState[b]=="undefined")break}m.stateToId[c]=b,m.idToState[b]=a}}return b},m.normalizeState=function(a){var b,c;if(!a||typeof a!="object")a={};if(typeof a.normalized!="undefined")return a;if(!a.data||typeof a.data!="object")a.data={};b={},b.normalized=!0,b.title=a.title||"",b.url=m.getFullUrl(m.unescapeString(a.url||d.location.href)),b.hash=m.getShortUrl(b.url),b.data=m.cloneObject(a.data),b.id=m.getIdByState(b),b.cleanUrl=b.url.replace(/\??\&_suid.*/,""),b.url=b.cleanUrl,c=!m.isEmptyObject(b.data);if(b.title||c)b.hash=m.getShortUrl(b.url).replace(/\??\&_suid.*/,""),/\?/.test(b.hash)||(b.hash+="?"),b.hash+="&_suid="+b.id;return b.hashedUrl=m.getFullUrl(b.hash),(m.emulated.pushState||m.bugs.safariPoll)&&m.hasUrlDuplicate(b)&&(b.url=b.hashedUrl),b},m.createStateObject=function(a,b,c){var d={data:a,title:b,url:c};return d=m.normalizeState(d),d},m.getStateById=function(a){a=String(a);var c=m.idToState[a]||m.store.idToState[a]||b;return c},m.getStateString=function(a){var b,c,d;return b=m.normalizeState(a),c={data:b.data,title:a.title,url:a.url},d=k.stringify(c),d},m.getStateId=function(a){var b,c;return b=m.normalizeState(a),c=b.id,c},m.getHashByState=function(a){var b,c;return b=m.normalizeState(a),c=b.hash,c},m.extractId=function(a){var b,c,d;return c=/(.*)\&_suid=([0-9]+)$/.exec(a),d=c?c[1]||a:a,b=c?String(c[2]||""):"",b||!1},m.isTraditionalAnchor=function(a){var b=!/[\/\?\.]/.test(a);return b},m.extractState=function(a,b){var c=null,d,e;return b=b||!1,d=m.extractId(a),d&&(c=m.getStateById(d)),c||(e=m.getFullUrl(a),d=m.getIdByUrl(e)||!1,d&&(c=m.getStateById(d)),!c&&b&&!m.isTraditionalAnchor(a)&&(c=m.createStateObject(null,null,e))),c},m.getIdByUrl=function(a){var c=m.urlToId[a]||m.store.urlToId[a]||b;return c},m.getLastSavedState=function(){return m.savedStates[m.savedStates.length-1]||b},m.getLastStoredState=function(){return m.storedStates[m.storedStates.length-1]||b},m.hasUrlDuplicate=function(a){var b=!1,c;return c=m.extractState(a.url),b=c&&c.id!==a.id,b},m.storeState=function(a){return m.urlToId[a.url]=a.id,m.storedStates.push(m.cloneObject(a)),a},m.isLastSavedState=function(a){var b=!1,c,d,e;return m.savedStates.length&&(c=a.id,d=m.getLastSavedState(),e=d.id,b=c===e),b},m.saveState=function(a){return m.isLastSavedState(a)?!1:(m.savedStates.push(m.cloneObject(a)),!0)},m.getStateByIndex=function(a){var b=null;return typeof a=="undefined"?b=m.savedStates[m.savedStates.length-1]:a<0?b=m.savedStates[m.savedStates.length+a]:b=m.savedStates[a],b},m.getHash=function(){var a=m.unescapeHash(d.location.hash);return a},m.unescapeString=function(b){var c=b,d;for(;;){d=a.unescape(c);if(d===c)break;c=d}return c},m.unescapeHash=function(a){var b=m.normalizeHash(a);return b=m.unescapeString(b),b},m.normalizeHash=function(a){var b=a.replace(/[^#]*#/,"").replace(/#.*/,"");return b},m.setHash=function(a,b){var c,e,f;return b!==!1&&m.busy()?(m.pushQueue({scope:m,callback:m.setHash,args:arguments,queue:b}),!1):(c=m.escapeHash(a),m.busy(!0),e=m.extractState(a,!0),e&&!m.emulated.pushState?m.pushState(e.data,e.title,e.url,!1):d.location.hash!==c&&(m.bugs.setHash?(f=m.getPageUrl(),m.pushState(null,null,f+"#"+c,!1)):d.location.hash=c),m)},m.escapeHash=function(b){var c=m.normalizeHash(b);return c=a.escape(c),m.bugs.hashEscape||(c=c.replace(/\%21/g,"!").replace(/\%26/g,"&").replace(/\%3D/g,"=").replace(/\%3F/g,"?")),c},m.getHashByUrl=function(a){var b=String(a).replace(/([^#]*)#?([^#]*)#?(.*)/,"$2");return b=m.unescapeHash(b),b},m.setTitle=function(a){var b=a.title,c;b||(c=m.getStateByIndex(0),c&&c.url===a.url&&(b=c.title||m.options.initialTitle));try{d.getElementsByTagName("title")[0].innerHTML=b.replace("<","&lt;").replace(">","&gt;").replace(" & "," &amp; ")}catch(e){}return d.title=b,m},m.queues=[],m.busy=function(a){typeof a!="undefined"?m.busy.flag=a:typeof m.busy.flag=="undefined"&&(m.busy.flag=!1);if(!m.busy.flag){h(m.busy.timeout);var b=function(){var a,c,d;if(m.busy.flag)return;for(a=m.queues.length-1;a>=0;--a){c=m.queues[a];if(c.length===0)continue;d=c.shift(),m.fireQueueItem(d),m.busy.timeout=g(b,m.options.busyDelay)}};m.busy.timeout=g(b,m.options.busyDelay)}return m.busy.flag},m.busy.flag=!1,m.fireQueueItem=function(a){return a.callback.apply(a.scope||m,a.args||[])},m.pushQueue=function(a){return m.queues[a.queue||0]=m.queues[a.queue||0]||[],m.queues[a.queue||0].push(a),m},m.queue=function(a,b){return typeof a=="function"&&(a={callback:a}),typeof b!="undefined"&&(a.queue=b),m.busy()?m.pushQueue(a):m.fireQueueItem(a),m},m.clearQueue=function(){return m.busy.flag=!1,m.queues=[],m},m.stateChanged=!1,m.doubleChecker=!1,m.doubleCheckComplete=function(){return m.stateChanged=!0,m.doubleCheckClear(),m},m.doubleCheckClear=function(){return m.doubleChecker&&(h(m.doubleChecker),m.doubleChecker=!1),m},m.doubleCheck=function(a){return m.stateChanged=!1,m.doubleCheckClear(),m.bugs.ieDoubleCheck&&(m.doubleChecker=g(function(){return m.doubleCheckClear(),m.stateChanged||a(),!0},m.options.doubleCheckInterval)),m},m.safariStatePoll=function(){var b=m.extractState(d.location.href),c;if(!m.isLastSavedState(b))c=b;else return;return c||(c=m.createStateObject()),m.Adapter.trigger(a,"popstate"),m},m.back=function(a){return a!==!1&&m.busy()?(m.pushQueue({scope:m,callback:m.back,args:arguments,queue:a}),!1):(m.busy(!0),m.doubleCheck(function(){m.back(!1)}),n.go(-1),!0)},m.forward=function(a){return a!==!1&&m.busy()?(m.pushQueue({scope:m,callback:m.forward,args:arguments,queue:a}),!1):(m.busy(!0),m.doubleCheck(function(){m.forward(!1)}),n.go(1),!0)},m.go=function(a,b){var c;if(a>0)for(c=1;c<=a;++c)m.forward(b);else{if(!(a<0))throw new Error("History.go: History.go requires a positive or negative integer passed.");for(c=-1;c>=a;--c)m.back(b)}return m};if(m.emulated.pushState){var o=function(){};m.pushState=m.pushState||o,m.replaceState=m.replaceState||o}else m.onPopState=function(b,c){var e=!1,f=!1,g,h;return m.doubleCheckComplete(),g=m.getHash(),g?(h=m.extractState(g||d.location.href,!0),h?m.replaceState(h.data,h.title,h.url,!1):(m.Adapter.trigger(a,"anchorchange"),m.busy(!1)),m.expectedStateId=!1,!1):(e=m.Adapter.extractEventData("state",b,c)||!1,e?f=m.getStateById(e):m.expectedStateId?f=m.getStateById(m.expectedStateId):f=m.extractState(d.location.href),f||(f=m.createStateObject(null,null,d.location.href)),m.expectedStateId=!1,m.isLastSavedState(f)?(m.busy(!1),!1):(m.storeState(f),m.saveState(f),m.setTitle(f),m.Adapter.trigger(a,"statechange"),m.busy(!1),!0))},m.Adapter.bind(a,"popstate",m.onPopState),m.pushState=function(b,c,d,e){if(m.getHashByUrl(d)&&m.emulated.pushState)throw new Error("History.js does not support states with fragement-identifiers (hashes/anchors).");if(e!==!1&&m.busy())return m.pushQueue({scope:m,callback:m.pushState,args:arguments,queue:e}),!1;m.busy(!0);var f=m.createStateObject(b,c,d);return m.isLastSavedState(f)?m.busy(!1):(m.storeState(f),m.expectedStateId=f.id,n.pushState(f.id,f.title,f.url),m.Adapter.trigger(a,"popstate")),!0},m.replaceState=function(b,c,d,e){if(m.getHashByUrl(d)&&m.emulated.pushState)throw new Error("History.js does not support states with fragement-identifiers (hashes/anchors).");if(e!==!1&&m.busy())return m.pushQueue({scope:m,callback:m.replaceState,args:arguments,queue:e}),!1;m.busy(!0);var f=m.createStateObject(b,c,d);return m.isLastSavedState(f)?m.busy(!1):(m.storeState(f),m.expectedStateId=f.id,n.replaceState(f.id,f.title,f.url),m.Adapter.trigger(a,"popstate")),!0};if(f){try{m.store=k.parse(f.getItem("History.store"))||{}}catch(p){m.store={}}m.normalizeStore()}else m.store={},m.normalizeStore();m.Adapter.bind(a,"beforeunload",m.clearAllIntervals),m.Adapter.bind(a,"unload",m.clearAllIntervals),m.saveState(m.storeState(m.extractState(d.location.href,!0))),f&&(m.onUnload=function(){var a,b;try{a=k.parse(f.getItem("History.store"))||{}}catch(c){a={}}a.idToState=a.idToState||{},a.urlToId=a.urlToId||{},a.stateToId=a.stateToId||{};for(b in m.idToState){if(!m.idToState.hasOwnProperty(b))continue;a.idToState[b]=m.idToState[b]}for(b in m.urlToId){if(!m.urlToId.hasOwnProperty(b))continue;a.urlToId[b]=m.urlToId[b]}for(b in m.stateToId){if(!m.stateToId.hasOwnProperty(b))continue;a.stateToId[b]=m.stateToId[b]}m.store=a,m.normalizeStore(),f.setItem("History.store",k.stringify(a))},m.intervalList.push(i(m.onUnload,m.options.storeInterval)),m.Adapter.bind(a,"beforeunload",m.onUnload),m.Adapter.bind(a,"unload",m.onUnload));if(!m.emulated.pushState){m.bugs.safariPoll&&m.intervalList.push(i(m.safariStatePoll,m.options.safariPollInterval));if(e.vendor==="Apple Computer, Inc."||(e.appCodeName||"")==="Mozilla")m.Adapter.bind(a,"hashchange",function(){m.Adapter.trigger(a,"popstate")}),m.getHash()&&m.Adapter.onDomLoad(function(){m.Adapter.trigger(a,"hashchange")})}},m.init()}(window)

/*********************************************** 
     Begin classes.js 
***********************************************/ 

/**
* Returns a box-styled element for injection into the DOM
*
* @param string class Any additonal classes to apply to the box.
* @param string checkbox The name attribute for the box's checkbox (the box will not be a checkbox box if this is not specified). The heading or subheading must contain the string "%(checkbox)s" for the checkbox to be rendered
* @param string heading The box's heading.
* @param string subheading The box's subheading.
* @param string body The box's contents.
*/
var Box = function(args) {
	var defaults = {
			'class':    '',
			checkbox:   undefined,
			heading:    undefined,
			subheading: undefined,
			body:       undefined
		},
		args = $.extend(defaults, args),
		box  = $('<div class="box" />').addClass(args.class),
		checkboxHTML;
	
	// Create the checkbox element, if needed
	if (args.checkbox !== undefined) {
		box.addClass('check-box');
		
		checkboxHTML = '<input type="checkbox" name="'+args.checkbox+'" />';
	}
	
	// Add the heading, if specified
	if (args.heading !== undefined) {
		// Add the checkbox to the heading, if it exists
		if (args.checkbox !== undefined) {
			args.heading = interpolate(args.heading, {checkbox: checkboxHTML}, true);
		// Otherwise just create the heading
		} else {
			box.append($('<p class="box-hd" />').html(args.heading));
		}
	}
	
	// Add the subheading, if specified
	if (args.subheading !== undefined) {
		// Add the checkbox to the subheading, if it exists and no heading was specified
		if (args.checkbox !== undefined && args.heading === undefined) {
			args.subheading = interpolate(args.subheading, {checkbox: checkboxHTML}, true);
			box.append($('<label class="box-shd" />').html(args.subheading));
		// Otherwise just create the subheading
		} else {
			box.append($('<p class="box-shd" />').html(args.subheading));
		}
	}
	
	// Add the body, if specified
	if (args.body !== undefined) {
		box.append($('<p class="box-bd" />').html(args.body));
	}
	
	return box;
},










/**
* Returns an origami-style element for injection into the DOM.
*/
Origami = function(args) {
	var defaults = {
			id:      '',
			'class': '',
			element: 'div',
			content: '',
			numeral: undefined,
			caption: ''
		},
		args = $.extend(defaults, args),
		
		origami = $('<'+args.element+' class="origami" />').addClass(args.class).attr('id', args.id),
		heading = $('<header class="origami-header" />').appendTo(origami),
		footer  = $('<footer class="origami-footer" />').appendTo(origami),
		
		content = $('<div class="origami-content" />').text(args.content).appendTo(heading),
		caption = $('<p class="origami-caption" />').text(args.caption).appendTo(footer);
	
	// Add the numeral, if specified
	if (args.numeral !== undefined) {
		content.prepend($('<p class="origami-num" />').text(args.numeral));
	}
	
	return origami;
};

/*********************************************** 
     Begin anime.js 
***********************************************/ 

var anime = (function($) {
	var canTransition = Modernizr.csstransitions,
		threshold = 20, // Maximum number of elements to animate
		win = $(window),
		
		/**
		* Ensures that the duration will be an object with a css and jquery property.
		*/
		normalizeDuration = function(duration) {
			if (typeof duration !== 'object') {
				duration = {
					css: duration,
					jquery: duration
				}
			}
			
			return duration;
		},
		
		/**
		* Restores the original CSS positioning of the elements.
		*/
		restorePositioning = function(elements) {
			// Remove the element placeholders
			var elementsClone = elements.clone().not('.animation-space-placeholder');
			
			// Restore positioning
			elementsClone.css({
				position: $(elements[0]).data('position'),
				zIndex: 'auto'
			});
			
			// Replace the elements in the DOM with our new element (single reflow)
			elements.replaceWith(elementsClone);
		}
		
		/**
		* Offsets an element to a specific position relative to its parent, and stores its origin position in the element.
		* @param element The element.
		* @param position Either an object specifying the top and bottom, or a function that returns such an object.
		*/
		offsetElement = function(element, position) {
			// Create a clone for working with in memory
			var elementClone = element.clone(),
				offset = element.position(),
				temp,
				left,
				top;
			
			// Store this to restore it later
			elementClone.data('position', element.css('position'));
			
			// Store the element's original position for later
			elementClone.data('top', offset.top);
			elementClone.data('left', offset.left);
			
			// Get the position to set it at
			if (typeof position === 'function') {
				temp = position({
					element: childClone,
					offset: childOffset
				});
				
				top  = temp.top;
				left = temp.left;
			} else {
				top  = position.top;
				left = position.left;
			}
			
			// Create a placeholder element to hold the space previously occupied by this element
			elementClone.clone().insertAfter(elementClone).css('visbility', 'hidden').addClass('animation-space-placeholder');
			
			elementClone.css({
				position: 'absolute', // position: absolute; must be set here, or else .position() will not work a few lines up from this one
				top: top,
				left: left,
				visibility: 'visible'
			});
			
			// Replace the element in the DOM with our new element (single reflow)
			element.replaceWith(elementClone);
			
			// Return the updated DOM element
			return elementClone;
		}
		
		/**
		* Offsets all children to a specific position relative to their parent, and stores their origin positions in the element.
		* @param parent The parent element.
		* @param position Either an object specifying the top and bottom, or a function that returns such an object.
		*/
		offsetChildren = function(parent, position) {
			var children = parent.children(), // We're animating its children
				
				// Create a clone for working with in memory
				parentClone = parent.clone(),
				childrenClone = parentClone.children();
			
			// Store this to restore it later
			$(childrenClone[0]).data('position', $(children[0]).css('position'));
			
			// Set the intial animation position on each element in memory
			childrenClone.each(function(i, childClone) {
				// Respect the threshold
				if (i === threshold) { return false; }
				
				childClone = $(childClone);
				
				var childOffset = $(children[i]).position(),
					temp,
					left,
					top;
				
				// Store the element's original position for later
				childClone.data('top', childOffset.top);
				childClone.data('left', childOffset.left);
				
				// Get the position to set it at
				if (typeof position === 'function') {
					temp = position({
						index: i,
						element: childClone,
						offset: childOffset
					});
					
					top  = temp.top;
					left = temp.left;
				} else {
					top  = position.top;
					left = position.left;
				}
				
				// Create a placeholder element to hold the space previously occupied by this element (the placeholder has its id removed)
				childClone.clone().insertAfter(childClone).css('visbility', 'hidden').addClass('animation-space-placeholder').attr('id', '');
				
				childClone.css({
					position: 'absolute', // position: absolute; must be set here, or else .position() will not work a few lines up from this one
					top: top,
					left: left,
					zIndex: 10001
				});
			});
			
			childrenClone.css('visibility', 'visible');
			
			// Replace the element in the DOM with our new element (single reflow)
			parent.replaceWith(parentClone);
			
			// Return the updated DOM element
			return parentClone;
		},
		
		/**
		* Runs the animation using CSS transitions if possible, or a jQuery .animate fallback
		* @param element The element to animate.
		* @param duration Either an integer or an object with css and jquery keys.
		* @param callback A function to call after the animation finishes.
		*/
		runAnimationOnElement = function(element, duration, callback) {
			// If the animation doesn't have a no-defer classs...
			if (!element.hasClass('animate-no-defer')) {
				element.addClass('animate-no-defer'); // Add the no-defer class
				
				// ...wait until the element scrolls into view to animate it
				element.on('inview', function (event, visible) {
					element.off('inview');
					
					if (visible === true) {
						runAnimationOnElement($(this), duration, callback);
					}
				});
				
				// And do nothing from this point on
				return;
			}
			
			duration = normalizeDuration(duration);
			
			if (canTransition) {
				// A slight delay is necessary for the CSS transition to trigger
				setTimeout(function() {
					// Set the element back to its original position
					element.css({
						top:  element.data('top'),
						left: element.data('left')
					});
				}, 10);
				
				// Clean up after ourselves once the animation has finished
				setTimeout(function() {
					if (typeof callback !== 'undefined') {
						callback(element);
					}
					
					restorePositioning(element);
				}, duration.css+10);
			} else {
				// jQuery .animate fallback for browsers that don't support CSS transitions
				
				// Set the element back to its original position
				element.animate({
					top: element.data('top'),
					left: element.data('left')
				}, {
					queue: false,
					duration: duration.jquery,
					complete: function() {
						// Clean up after ourselves once the animation has finished
						if (typeof callback !== 'undefined') {
							callback(element);
						}
					}
				});
				
				setTimeout(function() {
					restorePositioning(element);
				}, duration.jquery);
			}
		},
		
		/**
		* Runs the animation using CSS transitions if possible, or a jQuery .animate fallback
		* @param element The parent element.
		* @param duration Either an integer or an object with css and jquery keys.
		* @param callback A function to call after the animation finishes. The child element passed to it will either be an element or a collection of elements depending on whether we fell back on jQuery's animation.
		*/
		runAnimationOnChildren = function(element, duration, callback) {
			var children;
			
			// If the animation doesn't have a no-defer classs...
			if (!element.hasClass('animate-no-defer')) {
				element.addClass('animate-no-defer'); // Add the no-defer class
				
				// ...wait until the element scrolls into view to animate it
				element.on('inview', function (event, visible) {
					element.off('inview');
					
					if (visible === true) {
						runAnimationOnChildren($(this), duration, callback);
					}
				});
				
				// And do nothing from this point on
				return;
			}
			
			// Get the elements under the threshold (threshold*2 will include the placeholders in our query)
			children = element.children().slice(0, threshold*2);
			
			duration = normalizeDuration(duration);
			
			if (canTransition) {
				// A slight delay is necessary for the CSS transition to trigger
				setTimeout(function() {
					children.each(function(i, child) {
						child = $(child);
						
						// Set the element back to its original position
						child.css({
							top:  child.data('top'),
							left: child.data('left')
						});
					});
				}, 10);
				
				// Clean up after ourselves once the animation has finished
				setTimeout(function() {
					if (typeof callback !== 'undefined') {
						callback(element, children);
					}
					
					restorePositioning(children);
				}, duration.css+10);
			} else {
				// jQuery .animate fallback for browsers that don't support CSS transitions
				children.each(function(i, child) {
					child = $(child);
					
					// Set the element back to its original position
					child.animate({
						top: child.data('top'),
						left: child.data('left')
					}, {
						queue: false,
						duration: duration.jquery,
						complete: function() {
							// Clean up after ourselves once the animation has finished
							if (typeof callback !== 'undefined') {
								callback(element, $(this));
							}
						}
					});
					
					setTimeout(function() {
						restorePositioning(children);
					}, duration.jquery);
				});
			}
		},
		
		
		
		
		
		/**
		* Transitions the page content out to make way for dynamically loaded content.
		* @TODO Handle muting the menubar
		* @TODO We could do a better job of handling all these arguments
		*
		* @TODO This is a horrible, horrible mess and provides a shoddy user experience
		*/
		transitionPageTo = function(newMain, newMenubar, newFooter, newScripts, data) {
			body = $(document.body),
			
			main       = body.find('#wrap'),
			mainOffset = main.offset(),
			
			menubar = body.find('#toolbar'),
			
			oldHeight = main.height(),
			temp = newMain.clone().hide().appendTo(body), // Used to get the new height
			newHeight = temp.height(),
			
			backButton         = menubar.find('.back-btn'),
			newBackButton      = newMenubar.find('.back-btn'),
			hasBackButtonNow   = backButton.length,
			willHaveBackButton = newBackButton.length,
			
			searchForm    = menubar.find('#search'),
			newSearchForm = newMenubar.find('#search'),
			
			footer = body.find('#footer'),
			
			duration = {
				css: 750,
				jquery: 750
			};
			
			// @TODO Scroll to page top?
			// @TODO On some pages (like the cards page), the footer winds up halfway down the page
			
			body.find('#old-wrap, script').remove(); // Remove any possible remnants of an old transition and old scripts
			temp.remove();
			
			// Fade out and set the new page to the height of the original page
			newMain.css({
				height: oldHeight,
				opacity: 0
			}).data('original-positioning', newMain.css('position'));
			
			// Remove the old page from the flow and change its id
			main.css({
				position: 'absolute',
				left: mainOffset.left // @TODO This offset messes things up when leaving the study page
			}).attr('id', 'old-wrap');
			
			// Insert our new page before we animate
			newMain.insertAfter(main);
			
			// Load the new scripts for this page
			body.append(newScripts);
			
			if (canTransition) {
				// A slight delay is necessary for the CSS transition to trigger
				setTimeout(function() {
					// Fade the old page out
					main.css('opacity', 0);
					
					// Animate the new page as it comes in
					runAnimations();
					$(window).scroll(); // Trigger scroll events for the new page
					
					// Fade the new page in and smoothly adjust the page height
					newMain.css({
						opacity: 1,
						height: newHeight
					});
				}, 10);
				
				// Clean up after ourselves once the animation has finished
				setTimeout(function() {
					main.remove();
					newMain.css({
						position: newMain.data('original-positioning'),
						height: 'auto'
					});
				}, duration.css+10);
			} else {
				// jQuery .animate fallback for browsers that don't support CSS transitions
				
				// Fade the old page out
				main.animate({
					opacity: 0
				}, {
					queue: false,
					duration: duration.jquery,
					complete: function() {
						$(this).remove();
					}
				});
				
				// Animate the new page as it comes in
				$(window).scroll(); // Trigger scroll events for the new page
				runAnimations();
				
				// Fade the new page in and smoothly adjust the page height
				newMain.animate({
					opacity: 1,
					height: newHeight
				}, {
					queue: false,
					duration: duration.jquery,
					complete: function() {
						var that = $(this);
						
						that.css({
							position: that.data('original-positioning'),
							height: 'auto'
						});
					}
				});
			}
			
			// Update the classes on the menubar
			menubar.attr('class', newMenubar.attr('class'));
			
			// Animate any changes to the menubar's back button
			if (hasBackButtonNow || willHaveBackButton) {
				// @TODO If the buttons look the same, we should just swap them out with no animation
				
				// Remove the current button, if it exists
				if (hasBackButtonNow) {
					removeBackButton(backButton);
				}
				
				if (willHaveBackButton) {
					addBackButton(newBackButton);
				}
			}
			
			// Animate any changes to the menubar's search form
			if (searchForm.length !== newSearchForm.length) {
				if (searchForm.length) {
					hideSearchForm();
				} else {
					showSearchForm(newSearchForm);
				}
			}
			
			// Animate any changes to the footer
			if (footer.length !== newFooter.length) {
				if (footer.length) {
					hideFooter();
				} else {
					showFooter(newFooter);
				}
			}
			
			// Handle the home page
			if (body.hasClass('home-page')) {
				hideMural();
			} else if (data.home) {
				showMural();
			}
		},
		
		
		
		/**
		* Animates the background image up until it's off the page.
		*/
		hideMural = function() {
			var body = $(document.body),
				duration = {
					css: 1000,
					jquery: 1000
				};
			
			if (canTransition) {
				// @TODO getTransitionDuration method
				// A slight delay is necessary for the CSS transition to trigger
				setTimeout(function() {
					body.css('background-position', 'center -500px');
				}, 10);
				
				// Clean up after ourselves once the animation has finished
				setTimeout(function() {
					body.removeClass('home-page');
				}, duration.css+10);
			} else {
				// jQuery .animate fallback for browsers that don't support CSS transitions
				body.animate({
					backgroundPositionY: '-500px'
				}, {
					queue: false,
					duration: duration.jquery,
					complete: function() {
						$(this).removeClass('home-page');
					}
				});
			}
		},
		
		
		
		/**
		* Animates the background image down until it's on the page.
		*/
		showMural = function() {
			// @TODO This animation is broken in FF when coming back from a non pushed-state page
			var body = $(document.body),
				duration = {
					css: 1000,
					jquery: 1000
				};
			
			// This doesn't animate properly on pages that weren't brought in via AJAX if we don't disable transitions temporarily
			body.addClass('home-page no-transition').css('background-position', 'center -500px');
			
			if (canTransition) {
				// A slight delay is necessary for the CSS transition to trigger
				setTimeout(function() {
					body.removeClass('no-transition').css('background-position', 'center 0');
				}, 10);
			} else {
				// jQuery .animate fallback for browsers that don't support CSS transitions
				body.animate({
					backgroundPositionY: 0
				}, {
					queue: false,
					duration: duration.jquery
				});
			}
		},
		
		
		
		/**
		* Animates the search form out on the menubar.
		*/
		hideSearchForm = function() {
			var search = $('#search');
			
			search.remove();
		},
		
		/**
		* Animates the search form out on the menubar.
		*/
		showSearchForm = function(searchForm) {
			var masthead = $('#masthead');
			
			masthead.append(searchForm);
		},
		
		
		
		/**
		* Animates a back button out on the menubar.
		*/
		removeBackButton = function(button) {
			button.remove();
		},
		
		/**
		* Animates a back button in on the menubar.
		*/
		addBackButton = function(button) {
			var masthead = $('#masthead');
			
			masthead.prepend(button);
		},
		
		
		
		/**
		* Animates the footer out.
		*/
		hideFooter = function() {
			var footer = $('#footer');
			
			footer.remove();
		},
		
		/**
		* Animates the footer in.
		*/
		showFooter = function(newFooter) {
			var body = $(document.body);
			
			body.append(newFooter);
		},
		
		
		
		
		
		/**
		* Slides in each child element alternatively between left and right.
		*/
		zipperSlide = function(parent, duration) {
			// Store dimensions we'll need for calculations
			var parentWidth = parent.width(),
				parentPadding = parseInt(parent.css('padding-left'), 10) * 2,
				oddOffset = -parentWidth-parentPadding,
				evenOffset = parentWidth+parentPadding,
				children = parent.children();
			
			// Prevent scrollbars and get the height to prevent the parent from collapsing
			parent.css('overflow', 'hidden').css('height', parent.height());
			children.css('max-width', $(children[0]).width());
			
			// Offset the children and get the updated DOM element
			parent = offsetChildren(parent, function(child) {
				// Position the element off to the left or right
				var pos = {
					top:  child.offset.top,
					left: oddOffset
				};
				
				if (child.index%2 !== 0) { // even children
					pos.left = evenOffset;
				}
				
				return pos;
			});
			
			// Animate the elements
			runAnimationOnChildren(parent, duration, function(element, child) {
				element.css('overflow', 'auto');
				element.css('height', 'auto');
				
				child.css({
					maxWidth: 'none'
				});
			});
		},
		
		
		
		/**
		* Slides the left column in from the bottom left, and the right column from the bottom right.
		*/
		cornerSlide = function(parent, duration) {
			// Store dimensions we'll need for calculations
			var leftParentOffset = parent.position().left,
				topOffset = $(window).height() + $(document).scrollTop();
			
			// Get the height to prevent the parent from collapsing
			parent.css('height', parent.height());
			
			// Offset the children and get the updated DOM element
			parent = offsetChildren(parent, function(child) {
				// Position the element at the bottom left or right of the window
				var pos = {
					top:  topOffset,
					left: -leftParentOffset
				};
				
				if (child.index%2 !== 0) { // event children
					pos.left = child.offset.left + leftParentOffset;
				}
				
				return pos;
			});
			
			// Animate the elements
			runAnimationOnChildren(parent, duration, function(element, child) {
				element.css('height', 'auto');
			});
		},
		
		
		
		/**
		* Slides the element in from the left.
		*/
			slideFromLeft = function(element, duration) {
			// @TODO Things are all messed up for this in different browsers
			element = offsetElement(element, {
				top:  element.position().top,
				left: -element.width()
			});
			
			// Animate the elements
			runAnimationOnElement(element, duration);
		},
		
		
		
		
		
		runAnimations = function() {
			var animeQueue = $('#wrap').find('.animate');
			
			// For each element in the animation queue
			animeQueue.each(function(i, animeElement) {
				animeElement = $(animeElement);
				
				// Two column grid animation
				if (animeElement.hasClass('two-col')) {
					if (win.width()> 959) {
						cornerSlide(animeElement, {
							css: 1000,
							jquery: 850
						});
					} else {
						zipperSlide(animeElement, {
							css: 500,
							jquery: 350
						});
					}
				} else if (animeElement.hasClass('sidebar')) {
					slideFromLeft(animeElement, {
						css: 750,
						jquery: 750
					});
				}
			});
		};
	
	
	
	runAnimations();
	
	return {
		transitionPageTo: transitionPageTo,
		showMural:        showMural
	}
}(jQuery));

/*********************************************** 
     Begin jquery.inview.js 
***********************************************/ 

/**
 * author Remy Sharp
 * url http://remysharp.com/2009/01/26/element-in-view-event-plugin/
 */
(function ($) {
    function getViewportHeight() {
        var height = window.innerHeight; // Safari, Opera
        var mode = document.compatMode;

        if ( (mode || !$.support.boxModel) ) { // IE, Gecko
            height = (mode == 'CSS1Compat') ?
            document.documentElement.clientHeight : // Standards
            document.body.clientHeight; // Quirks
        }

        return height;
    }

    $(window).scroll(function () {
        var vpH = getViewportHeight(),
            scrolltop = (document.documentElement.scrollTop ?
                document.documentElement.scrollTop :
                document.body.scrollTop),
            elems = [];
        
        // naughty, but this is how it knows which elements to check for
        $.each($.cache, function () {
            if (this.events && this.events.inview) {
                elems.push(this.handle.elem);
            }
        });

        if (elems.length) {
            $(elems).each(function () {
                var $el = $(this),
                    top = $el.offset().top,
                    height = $el.height(),
                    inview = $el.data('inview') || false;

                if (scrolltop> (top + height) || scrolltop + vpH < top) {
                    if (inview) {
                        $el.data('inview', false);
                        $el.trigger('inview', [ false ]);                        
                    }
                } else if (scrolltop < (top + height)) {
                    if (!inview) {
                        $el.data('inview', true);
                        $el.trigger('inview', [ true ]);
                    }
                }
            });
        }
    });
    
    // kick the event to pick up any elements already in view.
    // note however, this only works if the plugin is included after the elements are bound to 'inview'
    $(function () {
        $(window).scroll();
    });
})(jQuery);


/*********************************************** 
     Begin main.js 
***********************************************/ 

// @codekit-prepend "json2.js"
// @codekit-prepend "amplify.store.min.js"
// @codekit-prepend "jquery.history.js"

// @codekit-prepend "classes.js"
// @codekit-prepend "anime.js"
// @codekit-prepend "jquery.inview.js"

// @codekit-append "card_listing.js"
// @codekit-append "launch.js"
// @codekit-append "study.js"
// @codekit-append "completion.js"



var Sleepless = (function($) {
	var body = $(document.body),
		
		yearOffset = 2012, // Our client-side date storing algorithm will only work for 127 years after this date
		
		storageSet = ! $.isEmptyObject(amplify.store()),
		
		History = window.History,
		
		
		
		
		/**
		* Converts a boolean value to an integer representation of that value (1 if true, 0 if false).
		* @param boolean bool The boolean value.
		* @return int Either 1 or 0.
		*/
		boolToInt = function(bool) {
			return bool ? 1 : 0;
		},
		
		/**
		* Determines whether the given date is today
		* @param Date date A date object to check if is today.
		* @return bool True if the date is today, false otherwise.
		*/
		isToday = function(date) {
			var today = new Date();
			
			return (date.getFullYear() === today.getFullYear() && date.getMonth() === today.getMonth() && date.getDate() === today.getDate());
		},
		
		/**
		* Converts an array of integer values into a query string of those values.
		* Example output for [1,2,3,4,5,7,8,9,11,12,14] would be: "1-5,7-9,11-12,14"
		* @param array arr The array of integer values.
		* @return string The string of values.
		*/
		encodeNumericArray = function(arr) {
			var queryString,
				len,
				i = 1; // The first value is added to the query string before we loop
			
			// If the array is not actually an array, or it is empty, return an empty string
			if (!$.isArray(arr) || arr.length === 0) {
				return '';
			}
			
			len = arr.length;
			arr.sort(function(a,b) {return a - b;}); // Ensure the array is sorted in numerical order
			queryString = arr[0] + ''; // Convert to string
			
			for (; i < len; i++) {
				// If this value is at the end of a range (ex: the 3 in [1,2,3,15])
				if (arr[i-1] === arr[i] - 1 && (i+1 === len || arr[i] !== arr[i+1] - 1)) {
					queryString += '-'+arr[i];
				} else if (arr[i-1] !== arr[i] - 1) {
					queryString += ','+arr[i];
				}
			}
			
			return queryString;
		},
		
		// Storage Methods
		
		/**
		* Packs the given values into a single character generated by the values' 16-bit binary representation.
		*
		* @param mixed values The values to pack in the format [val, bits], [val, bits], ... where the bits total up to 16. The first argument's binary representation will be on the lefthand side of the final binary representation.
		* @return string A single character generated from the 16-bit binary representation of the given values.
		*/
		pack = function() {
			var lastArgumentIndex = arguments.length - 1,
				len = arguments.length,
				i   = 0,
				binary;
			
			for (; i < len; i++) {
				if (i === lastArgumentIndex) {
					binary = binary | arguments[i][0];
				} else if (i > 0) {
					binary = (binary | arguments[i][0]) << arguments[i+1][1];
				} else {
					binary = arguments[i][0] << arguments[i+1][1];
				}
			}
			
			return String.fromCharCode(binary);
		},
		
		/**
		* Extracts bits from the given binary value from upperBit to lowerBit.
		* @param int binary The binary value to extract bits from.
		* @param int upperBit The rightmost bit to extract.
		* @param int lowerBit The leftmost bit to extract.
		* @return int The extracted bits.
		*/
		extractBits = function (binary, upperBit, lowerBit) {
			upperMask = (1 << upperBit) - 1;
			lowerMask = (1 << (lowerBit - 1)) - 1;
	 		
			return (binary & (upperMask ^ lowerMask)) >> (lowerBit - 1);
		},
		
		
		
		/**
		* Packs the given Date object into a single character.
		* @param Date date The date to pack.
		* @return string The packed date character.
		*/
		packDate = function(date) {
			var year  = date.getFullYear() - yearOffset,
				month = date.getMonth(),
				day   = date.getDate();
			
			// 4 bits for months, 5 bits for days, 7 bits for years
			return pack([month, 4], [day, 5], [year, 7]);
		},
		
		/**
		* Unpacks the given character into a Date object.
		* @param string character The character to unpack into a date.
		* @return Date The Date object represented by that character.
		*/
		unpackDate = function(date) {
			var charCode = date.charCodeAt(0),
				month = extractBits(charCode, 16, 13),
				day   = extractBits(charCode, 12, 8),
				year  = extractBits(charCode, 7, 1) + yearOffset;
			// 4 bits for months, 5 bits for days, 7 bits for years
			
			return new Date(year, month, day);
		}
		
		
		
		/**
		* Saves the deck data into client-side storage.
		* @param int id The id of the deck.
		* @param object data The data to save.
		*/
		saveProgress = function(data) {
			var deck  = data.deck,
				cards = data.cards,
				deckString = '',
				cardString = '',
				card_id,
				card;
			
			// First 3 characters are deck data
			deckString  = packDate(deck.lastStudyDate);
			deckString += pack(
				[Math.min(Math.max(deck.cardsPerSession, 1), 500), 9], // limit 500
				[Math.min(Math.max(deck.timeLimit, 1), 120), 7] // Limit 120
			);
			deckString += pack(
				[Math.min(Math.max(deck.randomizeSeed, 0), Math.pow(2, 13)-1), 13], // Limit 2^13 - 1
				[boolToInt(deck.reversed), 1],
				[boolToInt(deck.randomize), 1],
				[boolToInt(deck.useTime), 1]
			);
			deckString += pack([parseInt(deck.timesStudiedToday, 10), 16]);
			
			for (card_id in cards) {
				if (cards.hasOwnProperty(card_id) && $.isNumeric(card_id)) {
					card = cards[card_id];
					
					// Each card's data requires 3 characters
					cardString += packDate(card.reviewDate);
					cardString += pack(
						[Math.min(Math.max(card.delayFactor, 0), Math.pow(2, 14) - 1), 14], // Limit 2^14 - 1
						[boolToInt(card.reverseStudied), 1],
						[boolToInt(card.studied), 1]
					);
					cardString += pack([Math.min(Math.max(card.reverseDelayFactor, 0), Math.pow(2, 16)-1), 16]); // Limit 2^16 - 1
				}
			}
			
			amplify.store(data.id, deckString+cardString);
		},
		
		/**
		* Loads the deck data from client-side storage, or returns undefined if the deck was never saved.
		* @param int deckID The id of the deck to load data for.
		* @param object options Optiosn that determine how much data will be processed and returned. Possible options are loadCards, loadCardForecast, upcomingLoadedCallback. loadCardForecast will add an extra property to the returned object, data.cards.forecast, which contain these arrays of card IDs: studied, review, upcoming. upcomingLoadedCallback is a callback for when the upcoming forecast is loaded (yes, it can take time if the deck order is randomized)
		* @return object The loaded data in the format {id: deckID, deck: {deckDataField: deckData, ...}, cards: {order: {cardDataField: cardData, ...}}}. data.cards also contains a count, studyCount, and allStudied property with the total number of cards and studied cards, and whether all of the cards have been studied or not.
		*/
		loadProgress = function(deckID, options) {
			var defaults = {
					loadCards: true,
					loadCardForecast: false,
					upcomingLoadedCallback: false,
					forceReview: false
				},
				
				today         = new Date(),
				dayConversion = 1000 * 60 * 60 * 24,
				timeDifference,
				upcomingCardCount,
				closestDate = false, // Used to determine the closest review date to today
				
				storedData = amplify.store(deckID),
				
				data = {
					id:    deckID,
					deck:  {},
					cards: {
						count:      0,
						studyCount: 0,
						allStudied: false,
					}
				},
				
				dataArray,
				deckString,
				cardString;
			
			options = $.extend(defaults, options);
			
			if (options.loadCardForecast) {
				data.cards.forecast = {
					studied:  [],
					review:   [],
					upcoming: []
				};
			}
			
			// @TODO Oh boy what a mess this is...
			
			// If this deck has not been saved yet, return undefined
			if (storedData === undefined) {
				return undefined;
			}
			
			// Split the data string into an array of 3-character long strings starting after the fourth character (cards use 3 characters each, the deck uses the first 4)
			dataArray = storedData.substring(4).match(/[^]{3}/g);
			
			// Get the deck data
			deckString = storedData.substr(0, 4);
			
			// First character is the date
			data.deck.lastStudyDate = unpackDate(deckString.charAt(0));
			
			// The first 9 bits of the second character are the number of cards per session, the last 7 bits are the time limit
			data.deck.cardsPerSession = extractBits(deckString.charCodeAt(1), 16, 8);
			data.deck.timeLimit       = extractBits(deckString.charCodeAt(1), 7, 1);
			
			// The first 13 bits of the third character are the randomize seed, the last 3 bits are booleans
			data.deck.randomizeSeed = extractBits(deckString.charCodeAt(2), 16, 4);
			data.deck.reversed      = !!extractBits(deckString.charCodeAt(2), 3, 3);
			data.deck.randomize     = !!extractBits(deckString.charCodeAt(2), 2, 2);
			data.deck.useTime       = !!extractBits(deckString.charCodeAt(2), 1, 1);
			data.deck.timesStudiedToday = extractBits(deckString.charCodeAt(3), 16, 1);
			
			// Generate a string dictating the last time this deck was studied
			if (isToday(data.deck.lastStudyDate)) {
				data.deck.lastStudied = 'today';
			} else {
				data.deck.lastStudied = 'past';
				data.deck.timesStudiedToday = 0;
			}
			
			
			upcomingCardCount = data.deck.cardsPerSession; // The number of upcoming cards (used for determining which unstudied cards are coming up)
			
			// Unpack cards
			if (options.loadCards) {
				for (var i = 1, len = dataArray.length+1; i < len; i++) {
					cardString = dataArray[i-1];
					
					data.cards[i] = {
						// First character is the date
						reviewDate: unpackDate(cardString.charAt(0)),
						
						// The first 14 bits of the second character are the delay factor, the last 2 bits are booleans
						delayFactor:    extractBits(cardString.charCodeAt(1), 16, 3),
						reverseStudied: !!extractBits(cardString.charCodeAt(1), 2, 2),
						studied:        !!extractBits(cardString.charCodeAt(1), 1, 1),
						
						// The last character is the delay factor for the reversed card
						reverseDelayFactor: extractBits(cardString.charCodeAt(2), 16, 1)
					};
					
					data.cards.count++; // Increment the number of cards in this deck
					
					// If this card has been studied, increment the number of studied cards
					if (data.cards[i].studied) {
						data.cards.studyCount++;
					}
					
					
					// Update the card forecast with this card
					if (options.loadCardForecast) {
						// If the closest review date to today hasn't been set, initialize it
						if (!closestDate) {
							closestDate = data.cards[i].reviewDate;
						} else if (closestDate > data.cards[i].reviewDate) {
							closestDate = data.cards[i].reviewDate;
						}
						
						// If this card has been studied, check if it's upcoming or needs to be reviewed
						if (data.cards[i].studied) {
							timeDifference = (data.cards[i].reviewDate - today) / dayConversion; // Convert to days
							
							data.cards.forecast.studied.push(i); // Add this card's id to the list of studied cards
							
							// If its review date is today or in the past
							if (timeDifference <= data.deck.timesStudiedToday - 1) {
								data.cards.forecast.review.push(i);
							// If it's review date is one day from now
							} else if (timeDifference <= data.deck.timesStudiedToday) {
								data.cards.forecast.upcoming.push(i);
							}
						} else {
							// If the order isn't randomized and we should have unstudied cards coming up
							if (!data.deck.randomize && upcomingCardCount) {
								upcomingCardCount--; // This one's going to be added
								
								data.cards.forecast.upcoming.push(i); // Add this card to the forecast of upcoming cards
							}
						}
					}
				}
				
				// Determine whether all cards have been studied
				if (data.cards.studyCount === data.cards.count) {
					data.cards.allStudied = true;
				}
				
				// @TODO Support for changelogs
				
				// Determine which cards are upcoming that have not been studied yet if the deck is in random order
				if (options.loadCardForecast && data.deck.randomize && data.cards.count !== data.cards.studyCount) {
					$.getJSON('/decks/'+deckID+'/cards/', {
						total:   data.deck.cardsPerSession,
						studied: encodeNumericArray(data.cards.forecast.studied),
						randomize:     data.deck.randomize,
						randomizeSeed: data.deck.randomizeSeed
					}, function(cardsData) {
						// Set the upcoming card ids based on the data we got back
						$.each(cardsData, function(i, cardData) {
							data.cards.forecast.upcoming.push(cardData[0]);
						});
						
						// Run the callback for when upcoming card data is available
						if (options.upcomingLoadedCallback) {
							options.upcomingLoadedCallback(data);
						}
					});
				} else if (options.upcomingLoadedCallback) {
					// Run the callback for when upcoming card data is available
					options.upcomingLoadedCallback(data);
				}
				
				// If the user studied today and there are no review cards in the immediate future, find the closest review cards to today
				if ((data.deck.timesStudiedToday || options.forceReview) && data.cards.allStudied && options.loadCardForecast && !data.cards.forecast.review.length) {
					for (var i = 1, len = dataArray.length+1; i < len; i++) {
						if (data.cards[i].reviewDate.getTime() == closestDate.getTime()) {
							data.cards.forecast.review.push(i);
						}
					}
				}
			}
			
			return data;
		},
		
		
		
		/**
		* Initializes deck data for storage on the client side.
		* @return object An object representing the deck data.
		*/
		initializeDeckData = function() {
			var now = new Date(),
				dataField,
				deckData = {
					// The last time this deck was studied (initially a month in the past to prevent possible issues)
					lastStudyDate: 0,
					
					// Default values
					cardsPerSession: 20,
					timeLimit: 10,
					reversed: 0,
					randomize: 0,
					useTime: 0,
					randomizeSeed: Math.max(Math.floor(Math.random() * (Math.pow(2, 13))), 1), // Random number between 1 and 2^13 - 1
					timesStudiedToday: 0
				};
			
			now.setMonth(now.getMonth() - 1);
			deckData.lastStudyDate = now;
			
			// Check if a card-count or last-item field exists to determine the number of cards to study per session
			// All other fields we need should be present if one of these fields is
			dataField = $('input[name=cards-per-session], input[name=last-item]');
			if (dataField.length) {
				deckData.cardsPerSession = parseInt(dataField.val(), 10);
				
				// Get the time limit
				deckData.timeLimit = parseInt($('input[name=time-limit]').val(), 10);
				
				// Determine whether to use the reversed side
				
				dataField = $('input[name=use-reverse]');
				deckData.reversed = dataField.val();
				
				// Account for checkboxes, in case this field is not a typical input field
				if (deckData.reversed === 'on') {
					deckData.reversed = dataField.is(':checked');
				} else {
					deckData.reversed = !!deckData.reversed
				}
				
				
				// Determine whether to randomize the order
				
				dataField = $('input[name=randomize]');
				deckData.randomize = dataField.val();
				
				// Account for checkboxes, in case this field is not a typical input field
				if (deckData.randomize === 'on') {
					deckData.randomize = dataField.is(':checked');
				} else {
					deckData.randomize = !!deckData.randomize
				}
				
				
				// Determine whether to use a time limit
				
				dataField = $('input[name=use-time]');
				deckData.useTime = dataField.val();
				
				// Account for checkboxes, in case this field is not a typical input field
				if (deckData.useTime === 'on') {
					deckData.useTime = dataField.is(':checked');
				} else {
					deckData.useTime = !!deckData.useTime
				}
			}
			
			return deckData;
		}
		
		/**
		* Initializes card data for storage on the client side.
		* @param int cardCount The number of cards in the deck.
		* @return object An object in the format {orderInDeck: {cardDataField: cardData}, ...}
		*/
		initializeCardData = function(cardCount) {
			var cardData = {};
			
			for (var i = 1; i <= cardCount; i++) {
				cardData[i] = {
					// When to review the card
					reviewDate: new Date(),
					
					// Delay factor for setting the next review date for the card
					delayFactor:        0,
					reverseDelayFactor: 0,
					
					// Whether the card and its reversed side have been studied
					studied:        false,
					reverseStudied: false
				};
			}
			
			return cardData;
		},
		
		/**
		* Initializes progress data for storage on the client side.
		* @param int deckID The id of the deck to initialize storage for.
		* @param int cardCount The number of cards in the deck.
		* @return object The initialized progress data.
		*/
		initializeProgress = function(deckID, cardCount) {
			return {
				id:    deckID,
				deck:  initializeDeckData(),
				cards: initializeCardData(cardCount)
			};
		};
	
	
	// @TODO Any study buttons on the home and search page should be converted to forms by JS on click, to initialize the study interface appropriately
	
	
	// Animate the background image in if we're on the home page
	if (body.hasClass('home-page')) {
		anime.showMural();
	}
	
	// Remove the initial class after 2 seconds
	setTimeout(function() { body.removeClass('initial'); }, 2000);
	
	// @TODO Why do I do this?
	//History.replaceState({home: true}, '', window.location);
	
	$(window).on('statechange', function() {
		var State = History.getState();
		
		// @TODO We need a loader for while content is coming in (only if it hasn't come in after a short delay)
		$.ajax({
			url: State.url,
			type: State.data.method || 'GET', // Defaults to GET
			data: State.data,
			success: function(response) {
				var title,
					scripts = $(response).filter('script'); // @TODO There are 3 scripts that will always show up here... we could optimize
				
				response = $(response).not('script'); // Prevent scripts from being executed early
				title = response.filter('title').text();
				
				document.title = title;
				anime.transitionPageTo(response.filter('#wrap'), response.filter('#toolbar'), response.filter('#footer'), scripts, State.data);
			}
		});
	});
	
	
	
	// If the user clicks a study button anchor and they have progress saved, convert it to a form to preserve their settings
	if (storageSet) {
		body.on('click', 'a.study-btn', function(e) {
			var button   = $(this),
				progress = loadProgress(button.attr('data-deck-id')),
				deck,
				dataForm;
			
			// Only do anything if the user has progress saved for this deck
			if (progress) {
				e.preventDefault();
				
				deck = progress.deck;
				dataForm = $('<form method="POST" />').attr(
								'action', button.attr('href')
							).append(
								$('<input name="cards-per-session" value="'+deck.cardsPerSession+'" />')
							).append(
								$('<input type="checkbox" name="use-time" />').prop('checked', deck.useTime)
							).append(
								$('<input name="time-limit" value="'+deck.timeLimit+'" />')
							).append(
								$('<input type="checkbox" name="randomize" />').prop('checked', deck.randomize)
							).append(
								$('<input type="checkbox" name="use-reverse" />').prop('checked', deck.reversed)
							).append(
								$('<input name="randomize-seed" value="'+deck.randomizeSeed+'" />')
							).append(
								$('input[name=csrfmiddlewaretoken]').clone()
							).hide().appendTo(
								body
							).submit();
			}
		});
	}
	
	
	
	
	body.on('click', '.page-transition-button', function(e) {
		e.preventDefault();
		
		var that = $(this),
			data = {
				home: that.hasClass('home-link')
			};
		
		History.pushState(data, '', that.attr('href'));
	});
	
	
	body.on('submit', '.page-transition-form', function(e) {
		e.preventDefault();
		
		var that = $(this),
			method = that.attr('method').toLowerCase(),
			fields = that.find('input, textarea'),
			formData;
		
		// GET request
		if (method === 'get') {
			formData = '';
			
			// @TODO Use jQuery.serialize() on the form to get the query string
			fields.each(function(index, field) {
				field = $(field);
				
				if (field.attr('name') !== undefined) {
					formData += field.attr('name')+'='+encodeURIComponent(field.val());
				}
			});
			
			History.pushState(null, '', that.attr('action')+'?'+formData);
		// POST request
		} else if (method === 'post') {
			// @TODO This is totally broken
			formData = {method: 'POST'};
			
			fields.each(function(index, field) {
				field = $(field);
				
				// @TODO Use jQuery.serialize() on the form to get the query string
				if (field.attr('name') !== undefined) {
					if (field.attr('type') === 'checkbox') {
						// Checkboxes must have their value checked in this way
						if (field.is(':checked')) {
							formData[field.attr('name')] = true;
						}
					} else {
						formData[field.attr('name')] = field.val();
					}
				}
			});
			
			History.pushState(formData, '', that.attr('action'));
		}
	});
	
	
	
	return {
		// Properties
		storageSet: storageSet,
		
		
		// Methods
		isToday:            isToday,
		encodeNumericArray: encodeNumericArray,
		
		initializeProgress: initializeProgress,
		saveProgress: saveProgress,
		loadProgress: loadProgress
	};
}(jQuery));

/*********************************************** 
     Begin card_listing.js 
***********************************************/ 

(function($) {
	var body = $(document.body),
		isCardPage = body.hasClass('card-listing');
	
	// If we're on the card listing page and we have storage set, we can mark cards as studied or upcoming
	if (isCardPage && Sleepless.storageSet) {
		var cards = body.find('.card'),
			
			upcomingCallback = function(progress) {
				// Mark each studied card as such
				$.each(progress.cards.forecast.studied, function(i, cardOrder) {
					cards.filter('#card-'+cardOrder).addClass('completed-card');
				});
				
				// Mark each upcoming card as such
				$.each(progress.cards.forecast.upcoming, function(i, cardOrder) {
					cards.filter('#card-'+cardOrder).addClass('upcoming-card');
				});
			},
			
			deckID   = parseInt($('.deck-id').attr('id').replace('deck-', ''), 10),
			progress = Sleepless.loadProgress(deckID, {
				loadCardForecast:       true,
				upcomingLoadedCallback: upcomingCallback
			});
	}
}(jQuery));

/*********************************************** 
     Begin launch.js 
***********************************************/ 

(function($) {
	var body = $(document.body),
		isLaunchPage = body.hasClass('launch');
	
	if (isLaunchPage) {
		var hooks = {
				jsStudyOptions:     $('#js-study-options'),
				staticStudyOptions: $('#static-study-options')
			},
			
			jsHookClone = hooks.jsStudyOptions.clone(),
			
			fields = {
				randomizeSeed:  $('<input type="hidden" name="randomize-seed" />'),
				cardCount:      hooks.staticStudyOptions.find('input[name=cards-per-session]'),
				recordProgress: undefined,
				cardForecast:   $('<p class="pad option-text" />').appendTo(jsHookClone)
			},
			
			
			deckID      = parseInt($('.deck-id').attr('id').replace('deck-', ''), 10),
			cardCount   = parseInt($('.card-count').text(), 10),
			reviewCount = 0,
			progress,
			
			
			updateCardForecast = function(cardCount, reviewCount) {
				// If the user is at the end of the deck, this will make the number of new cards to study equal to the number of new cards actually in the deck
				if (progress !== undefined) {
					cardCount = Math.min(cardCount, progress.cards.count - progress.cards.studyCount);
				}
				
				cardCount += reviewCount;
				
				if (cardCount === 0) {
					// If there are no cards to study for today, we'll want to focus on the number of early review cards
					cardCount = Sleepless.loadProgress(deckID, {loadCardForecast: true, forceReview: true}).cards.forecast.review.length;
					
					fields.cardForecast.text(
						interpolate(
							ngettext(
								"You have nothing to review today! If you want to review early, you will have %s card to study.",
								"You have nothing to review today! If you want to review early, you will have %s cards to study.",
								cardCount
							),
							[cardCount]
						)
					);
				} else if (progress && progress.deck.lastStudied === 'today') {
					fields.cardForecast.text(
						interpolate(
							ngettext(
								"You've already studied this deck for today. If you want to review early, you will have %s card to study.",
								"You've already studied this deck for today. If you want to review early, you will have %s cards to study.",
								cardCount
							),
							[cardCount]
						)
					);
				} else {
					fields.cardForecast.text(
						interpolate(
							ngettext('You have %s card to study today.', 'You have %s cards to study today.', cardCount),
							[cardCount]
						)
					);
				}
			};
		
		
		
		// Only show the progress recording consent box if storage has not been set
		if (!Sleepless.storageSet) {
			// Create the checkbox box
			fields.recordProgress = new Box({
				'class':    'attention-box',
				checkbox:   'record',
				subheading: gettext('%(checkbox)s Record your progress?'),
				body:       gettext('Sleepless can record your progress in this deck for next time. As a guest, your progress will not be available on other devices.')
			}).prependTo(
				jsHookClone
			);
			
			// When the checkbox is checked, we'll remove this element and begin storing data
			fields.recordProgress.find('input[type=checkbox]').on('click', function() {
				var checkbox = $(this);
				
				// Only fire if the checkbox has been checked
				if (checkbox.is(':checked')) {
					// Remove the checkbox
					fields.recordProgress.remove();
					
					// Save progress in this deck
					Sleepless.saveProgress(Sleepless.initializeProgress(deckID, cardCount));
				}
			});
		} else {
			progress = Sleepless.loadProgress(deckID, {loadCardForecast: true});
			
			// Check if progress has been set for this deck
			if (progress !== undefined) {
				// Update the number of cards to review today
				reviewCount = progress.cards.forecast.review.length;
				
				// Set the randomize seed to the user's for this deck
				fields.randomizeSeed.val(progress.deck.randomizeSeed).appendTo(jsHookClone);
				
				// Change the values in the form fields according to the stored data
				hooks.staticStudyOptions.find('input[name=cards-per-session]').val(progress.deck.cardsPerSession);
				hooks.staticStudyOptions.find('input[name=time-limit]').val(progress.deck.timeLimit);
				hooks.staticStudyOptions.find('input[name=use-time]').prop('checked', progress.deck.useTime);
				hooks.staticStudyOptions.find('input[name=randomize]').prop('checked', progress.deck.randomize);
				hooks.staticStudyOptions.find('input[name=use-reverse]').prop('checked', progress.deck.reversed);
				
				// Remove new card options if there are no new cards
				if (progress.cards.allStudied) {
					hooks.staticStudyOptions.find('input[name=cards-per-session]').parent().remove();
				}
			}
		}
		
		
		
		
		
		
		// @TODO We need to handle cases where the user exits part way through the session and comes back the same day or another day
		// @TODO Only call this whenever fields.cardCount is updated if this deck hasn't been studied today
		// Display the card forecast for this deck and update it whenever the number of new cards to study is changed
		updateCardForecast(parseInt(fields.cardCount.val(), 10), reviewCount);
		fields.cardCount.on('keyup change', function() {
			updateCardForecast(parseInt(fields.cardCount.val(), 10), reviewCount);
		});
		
		hooks.jsStudyOptions.replaceWith(jsHookClone);
	}
}(jQuery));

/*********************************************** 
     Begin study.js 
***********************************************/ 

(function($) {
	var content = $('#wrap'),
		isStudyPage = content.hasClass('study-page');
	
	if (isStudyPage) {
		var cardFront = content.find('.card-front');
		
		// Allow the front of the card to be centered vertically
		if (cardFront.length !== 0) {
			cardFront.parent().css('line-height', cardFront.parent().height()+'px');
		}
		
		
		
		// If progress is being saved, we can provide a better studying experience
		if (Sleepless.storageSet) {
			var form  = $('#study-form'),
				front = $('#front'),
				back  = $('#back'),
				
				
				elements = {
					// Card elements
					card: {
						front: front,
						back:  back.find('.card'),
						fields: {
							front: $('.front-field'),
							back:  $('.back-field'),
							extra: $('.extra-field')
						}
					},
					
					// Form elements
					currentItem: form.find('input[name=current-item]'),
					lastItem:    form.find('input[name=last-item]'),
					
					// Status elements
					status: {
						container:   $('.study-status'),
						currentItem: $('.study-progress .current-item'),
						lastItem:    $('.study-progress .last-item'),
						repeatCount: $('.study-repeats')
					}
				},
				
				
				/**
				* Updates the card fields in the DOM with the given card data.
				* @param hash cardData A hash with the front, back, and extra card data to insert into the DOM.
				*/
				updateCardFields = function(cardData) {
					// @TODO 3 reflows, this could be better
					elements.card.fields.front.text(cardData.front);
					elements.card.fields.back.text(cardData.back);
					elements.card.fields.extra.text(cardData.extra);
				},
				
				
				/**
				* Updates the repeated card counter in the DOM.
				*/
				updateRepeatCounter = function() {
					// If the repeated card counter is not currently in the DOM, we'll have to create it.
					if (!elements.status.repeatCount.length) {
						elements.status.repeatCount = $('<span class="study-status-item study-repeats" />').appendTo(elements.status.container);
					}
					
					// Update the repeated card counter if there are cards in the repeat queue
					if (repeatQueue.length) {
						elements.status.repeatCount.text(repeatQueue.length);
					// Otherwise, remove it
					} else {
						elements.status.repeatCount.remove();
						elements.status.repeatCount = $();
					}
				},
				
				
				/**
				* Returns an array of the number of days each option should delay the card's review by.
				* @param number numberOfOptions The number of delay options that are available to the user.
				* @param number delayFactor The delay factor for this card.
				* @return array An array of the number of days each option should delay by
				*/
				getDelayTimes = function(numberOfOptions, delayFactor) {
					times = [];
					
					for (var i = 0; i < numberOfOptions; i++) {
						times.push(Math.ceil(Math.pow(delayFactor + 2, i + 1 - (i*0.5))));
					}
					
					return times;
				},
				
				
				/**
				* Returns the delay time as a human-readable HTML string.
				* @param number days The number of days that delay would be delayed by.
				* @return string A human readable HTML string.
				*/
				getDelayTimeString = function(days) {
					var numeral = '<span class="button-numeral">NUMERAL</span>',
						time;
					
					// Display the time in terms of days
					if (days < 31) {
						numeral = numeral.replace('NUMERAL', days);
						return interpolate(ngettext('%s day', '%s days', days), [numeral]);
						
					// Display the time in terms of months
					} else if (days < 365) {
						time = Math.round( days / 31 * 10 ) / 10; // Round to 0 or 1 decimal places
						
						numeral = numeral.replace('NUMERAL', time);
						return interpolate(ngettext('%s month', '%s months', time), [numeral]);
						
					// Display the time in terms of years
					} else {
						time = Math.round( days / 365 * 10 ) / 10; // Round to 0 or 1 decimal places
						
						numeral = numeral.replace('NUMERAL', time);
						return interpolate(ngettext('%s year', '%s years', time), [numeral]);
					}
				},
				
				
				startTime   = new Date().getTime() / 1000,
				currentItem = 0,
				lastItem    = 20,
				repeatQueue = [],
				currentCardID,
				currentCard,
				cards,
				
				
				deckID    = content.find('.deck-id').val(),
				cardCount = content.find('.card-count').val(),
				
				
				// Load our progress in this deck
				progress = Sleepless.loadProgress(deckID, {loadCardForecast: true, forceReview: true});
			
			
			
			// If progress hasn't been saved yet, initialize it
			if (progress === undefined) {
				Sleepless.saveProgress(Sleepless.initializeProgress(deckID, cardCount));
				progress = Sleepless.loadProgress(deckID, {loadCardForecast: true, forceReview: true});
			}
			
			// Update the options for this deck
			progress.deck.useTime    = !!form.find('input[name=use-time]').val();
			progress.deck.timeLimit  = parseInt(form.find('input[name=time-limit]').val(), 10) / 60;
			progress.deck.randomize  = !!form.find('input[name=randomize]').val();
			progress.deck.useReverse = !!form.find('input[name=use-reverse]').val();
			progress.deck.cardsPerSession = parseInt(form.find('input[name=cards-per-session]').val(), 10);
			progress.deck.timesStudiedToday++;
			progress.deck.lastStudyDate = new Date(); // Set the last study date to today
			
			Sleepless.saveProgress(progress); // Save changes to the user's progress
			
			
			
			// Add review delay form elements to the DOM
			$('<button type="submit" class="btn bad-btn large-btn" name="repeat" value="1" id="repeat">'+gettext('Repeat')+'</button>').hide().appendTo(form);
			
			$('<div class="good-review-delay-options" />').append(
				$('<p class="review-delay-caption">'+gettext('Review in')+'</p>')
			).append(
				$('<button type="submit" class="btn good-btn large-btn" name="short-review-delay" value="1" />')
			).append(
				$('<button type="submit" class="btn good-btn large-btn" name="medium-review-delay" value="1" />')
			).append(
				$('<button type="submit" class="btn good-btn large-btn" name="long-review-delay" value="1" />')
			).hide().appendTo(form);
			
			elements.showAnswer = form.find('#show-answer');
			// @TODO This is kind of bad
			elements.reviewOptions = {
				container:   form.find('#repeat, .good-review-delay-options'),
				buttons:     $('#repeat, .good-review-delay-options button'),
				goodButtons: $('.good-review-delay-options').find('button')
			};
			
			
			
			// Hide pertinent UI elements until our card data loads in
			elements.status.container.hide();
			elements.card.front.hide();
			elements.showAnswer.hide();
			
			
			// Fetch the card data we'll need for this session
			$.getJSON('/decks/'+deckID+'/cards/', {
				total:   progress.deck.cardsPerSession,
				studied: Sleepless.encodeNumericArray(progress.cards.forecast.studied),
				include: Sleepless.encodeNumericArray(progress.cards.forecast.review),
				randomize:     progress.deck.randomize,
				randomizeSeed: progress.deck.randomizeSeed
			}, function(data) {
				cards = data
				
				
				// Set up our session variables
				lastItem = data.length;
				elements.status.lastItem.text(lastItem);
				elements.lastItem.val(lastItem);
				
				
				// @TODO Write a method for this
				currentCardDataIndex = 0; // Current index in our card data array
				currentCardID = cards[0][0]; // First item is the card's order in the deck
				currentCard = cards[0][1]; // Second item is a hash of card data
				updateCardFields(currentCard);
				
				elements.status.container.show();
				elements.card.front.show(); // Show the front of the current card
				elements.showAnswer.show(); // Show the "show answer" button
				
				
				// Show the other side of the card
				elements.showAnswer.on('click', function(e) {
					var times;
					
					e.preventDefault();
					// @TODO Keyboard shortcuts
					// Swap the form controls
					elements.showAnswer.hide();
					elements.reviewOptions.container.show();
					
					// Show the back of the card
					elements.card.back.show();
					
					
					// Present the user with delay options for when to next review this card
					times = getDelayTimes(elements.reviewOptions.goodButtons.length, progress.cards[currentCardID].delayFactor);
					elements.reviewOptions.goodButtons.each(function(i) {
						$(this).val(times[i]).html(getDelayTimeString(times[i]));
					});
					
					
					// Update our current item if it's not also our last item
					if (currentItem !== lastItem) {
						currentItem++;
						elements.currentItem.val(currentItem);
						elements.status.currentItem.text(currentItem);
					// If we have cards in the repeat queue, we should remove the first item now
					} else if (repeatQueue.length) {
						repeatQueue.shift(); // We have to remove the item here to prevent the session from ending prematurely
						
						// Update the repeated card counter in the DOM
						updateRepeatCounter();
					}
				});
				
				// Show the next card
				elements.reviewOptions.buttons.on('click', function(e) {
					var button = $(e.currentTarget);
					
					e.preventDefault();
					
					// @TODO Keyboard shortcuts
					// Swap the form controls
					elements.showAnswer.show();
					elements.reviewOptions.container.hide();
					
					// Hide the back of the card
					elements.card.back.hide();
					
					
					progress.cards[currentCardID].studied = true;
					
					// If the repeat button was clicked
					if (button.attr('name') === 'repeat') {
						// Reset the delay factor for this card
						progress.cards[currentCardID].delayFactor = 0;
						
						// Add this card's index in our card data array to the repeat queue
						repeatQueue.push(currentCardDataIndex);
						
						// Update the repeated card counter in the DOM
						updateRepeatCounter();
					// If a review delay button was clicked
					} else {
						// Set the card's next review date
						progress.cards[currentCardID].reviewDate.setDate(new Date().getDate() + parseInt(button.val(), 10));
						
						// Increment the card's delayFactor
						progress.cards[currentCardID].delayFactor += 1;
					}
					
					
					// Save our progress
					Sleepless.saveProgress(progress);
					
					
					// If the time limit is up, submit the form
					if (progress.deck.useTime && (new Date().getTime() / 1000 - startTime) / 60 >= progress.deck.timeLimit) {
						form.submit();
						return;
					}
					
					// If this is the last item and we don't have a repeat queue, submit the form
					if (currentItem === lastItem && !repeatQueue.length) {
						form.submit();
						return;
					}
					
					
					
					// If the current item is not the last item, our next card should come from the regular queue
					if (currentItem !== lastItem) {
						currentCardDataIndex = currentItem; // Current index in our card data array
						currentCardID = cards[currentItem][0]; // First item is the card's order in the deck
						currentCard = cards[currentItem][1]; // Second item is a hash of card data
					// Otherwise, the next card should come from the repeat queue
					} else {
						// Get the value of the next card's order from the repeat queue, but don't remove it from the queue
						// This prevents the session from ending prematurely after the user chooses "show answer" on the last repeated card
						currentCardDataIndex = repeatQueue[0]; // Current index in our card data array
						currentCardID = cards[repeatQueue[0]][0]; // First item is the card's order in the deck
						currentCard = cards[repeatQueue[0]][1]; // Second item is a hash of card data
					}
					
					// Inject the new card into the DOM
					updateCardFields(currentCard);
				});
			});
		}
	}
}(jQuery));

/*********************************************** 
     Begin completion.js 
***********************************************/ 

(function($) {
	var content = $('#wrap'),
		isCompletionPage = content.hasClass('completion-page');
	
	if (isCompletionPage && Sleepless.storageSet) {
		var sidebar = $('.sidebar'),
			
			deckID = parseInt($('.deck-id').attr('id').replace('deck-', ''), 10),
			
			upcomingCallback = function(progress) {
				sidebar.append(new Origami({
					element: 'li',
					id:      'completion-cards-tomorrow',
					'class': 'upcoming',
					numeral: progress.cards.forecast.upcoming.length,
					caption: gettext('Tomorrow')
				}));
			},
			
			progress = Sleepless.loadProgress(deckID, {
				loadCardForecast:       true,
				upcomingLoadedCallback: upcomingCallback
			});
	}
}(jQuery));