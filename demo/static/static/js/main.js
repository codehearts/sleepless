// @codekit-prepend "json2.js"
// @codekit-prepend "amplify.store.min.js"
// @codekit-prepend "jquery.history.js"

// @codekit-prepend "classes.js"
// @codekit-prepend "anime.js"
// @codekit-prepend "jquery.inview.js"

// @codekit-append "card_listing.js"
// @codekit-append "launch.js"
// @codekit-append "study.js"
// @codekit-append "completion.js"



var Sleepless = (function($) {
	var body = $(document.body),
		
		yearOffset = 2012, // Our client-side date storing algorithm will only work for 127 years after this date
		
		storageSet = ! $.isEmptyObject(amplify.store()),
		
		History = window.History,
		
		
		
		
		/**
		* Converts a boolean value to an integer representation of that value (1 if true, 0 if false).
		* @param boolean bool The boolean value.
		* @return int Either 1 or 0.
		*/
		boolToInt = function(bool) {
			return bool ? 1 : 0;
		},
		
		/**
		* Determines whether the given date is today
		* @param Date date A date object to check if is today.
		* @return bool True if the date is today, false otherwise.
		*/
		isToday = function(date) {
			var today = new Date();
			
			return (date.getFullYear() === today.getFullYear() && date.getMonth() === today.getMonth() && date.getDate() === today.getDate());
		},
		
		/**
		* Converts an array of integer values into a query string of those values.
		* Example output for [1,2,3,4,5,7,8,9,11,12,14] would be: "1-5,7-9,11-12,14"
		* @param array arr The array of integer values.
		* @return string The string of values.
		*/
		encodeNumericArray = function(arr) {
			var queryString,
				len,
				i = 1; // The first value is added to the query string before we loop
			
			// If the array is not actually an array, or it is empty, return an empty string
			if (!$.isArray(arr) || arr.length === 0) {
				return '';
			}
			
			len = arr.length;
			arr.sort(function(a,b) {return a - b;}); // Ensure the array is sorted in numerical order
			queryString = arr[0] + ''; // Convert to string
			
			for (; i < len; i++) {
				// If this value is at the end of a range (ex: the 3 in [1,2,3,15])
				if (arr[i-1] === arr[i] - 1 && (i+1 === len || arr[i] !== arr[i+1] - 1)) {
					queryString += '-'+arr[i];
				} else if (arr[i-1] !== arr[i] - 1) {
					queryString += ','+arr[i];
				}
			}
			
			return queryString;
		},
		
		// Storage Methods
		
		/**
		* Packs the given values into a single character generated by the values' 16-bit binary representation.
		*
		* @param mixed values The values to pack in the format [val, bits], [val, bits], ... where the bits total up to 16. The first argument's binary representation will be on the lefthand side of the final binary representation.
		* @return string A single character generated from the 16-bit binary representation of the given values.
		*/
		pack = function() {
			var lastArgumentIndex = arguments.length - 1,
				len = arguments.length,
				i   = 0,
				binary;
			
			for (; i < len; i++) {
				if (i === lastArgumentIndex) {
					binary = binary | arguments[i][0];
				} else if (i > 0) {
					binary = (binary | arguments[i][0]) << arguments[i+1][1];
				} else {
					binary = arguments[i][0] << arguments[i+1][1];
				}
			}
			
			return String.fromCharCode(binary);
		},
		
		/**
		* Extracts bits from the given binary value from upperBit to lowerBit.
		* @param int binary The binary value to extract bits from.
		* @param int upperBit The rightmost bit to extract.
		* @param int lowerBit The leftmost bit to extract.
		* @return int The extracted bits.
		*/
		extractBits = function (binary, upperBit, lowerBit) {
			upperMask = (1 << upperBit) - 1;
			lowerMask = (1 << (lowerBit - 1)) - 1;
	 		
			return (binary & (upperMask ^ lowerMask)) >> (lowerBit - 1);
		},
		
		
		
		/**
		* Packs the given Date object into a single character.
		* @param Date date The date to pack.
		* @return string The packed date character.
		*/
		packDate = function(date) {
			var year  = date.getFullYear() - yearOffset,
				month = date.getMonth(),
				day   = date.getDate();
			
			// 4 bits for months, 5 bits for days, 7 bits for years
			return pack([month, 4], [day, 5], [year, 7]);
		},
		
		/**
		* Unpacks the given character into a Date object.
		* @param string character The character to unpack into a date.
		* @return Date The Date object represented by that character.
		*/
		unpackDate = function(date) {
			var charCode = date.charCodeAt(0),
				month = extractBits(charCode, 16, 13),
				day   = extractBits(charCode, 12, 8),
				year  = extractBits(charCode, 7, 1) + yearOffset;
			// 4 bits for months, 5 bits for days, 7 bits for years
			
			return new Date(year, month, day);
		},
		
		
		
		/**
		* Saves the deck data into client-side storage.
		* @param int id The id of the deck.
		* @param object data The data to save.
		*/
		saveProgress = function(data) {
			var deck  = data.deck,
				cards = data.cards,
				deckString = '',
				cardString = '',
				card_id,
				card;
			
			// First 3 characters are deck data
			deckString  = packDate(deck.lastStudyDate);
			deckString += pack(
				[Math.min(Math.max(deck.cardsPerSession, 1), 500), 9], // limit 500
				[Math.min(Math.max(deck.timeLimit, 1), 120), 7] // Limit 120
			);
			deckString += pack(
				[Math.min(Math.max(deck.randomizeSeed, 0), Math.pow(2, 13)-1), 13], // Limit 2^13 - 1
				[boolToInt(deck.reversed), 1],
				[boolToInt(deck.randomize), 1],
				[boolToInt(deck.useTime), 1]
			);
			deckString += pack([parseInt(deck.timesStudiedToday, 10), 16]);
			
			for (card_id in cards) {
				if (cards.hasOwnProperty(card_id) && $.isNumeric(card_id)) {
					card = cards[card_id];
					
					// Each card's data requires 3 characters
					cardString += packDate(card.reviewDate);
					cardString += pack(
						[Math.min(Math.max(card.delayFactor, 0), Math.pow(2, 14) - 1), 14], // Limit 2^14 - 1
						[boolToInt(card.reverseStudied), 1],
						[boolToInt(card.studied), 1]
					);
					cardString += pack([Math.min(Math.max(card.reverseDelayFactor, 0), Math.pow(2, 16)-1), 16]); // Limit 2^16 - 1
				}
			}
			
			amplify.store(data.id, deckString+cardString);
		},
		
		/**
		* Loads the deck data from client-side storage, or returns undefined if the deck was never saved.
		* @param int deckID The id of the deck to load data for.
		* @param object options Optiosn that determine how much data will be processed and returned. Possible options are loadCards, loadCardForecast, upcomingLoadedCallback. loadCardForecast will add an extra property to the returned object, data.cards.forecast, which contain these arrays of card IDs: studied, review, upcoming. upcomingLoadedCallback is a callback for when the upcoming forecast is loaded (yes, it can take time if the deck order is randomized)
		* @return object The loaded data in the format {id: deckID, deck: {deckDataField: deckData, ...}, cards: {order: {cardDataField: cardData, ...}}}. data.cards also contains a count, studyCount, and allStudied property with the total number of cards and studied cards, and whether all of the cards have been studied or not.
		*/
		loadProgress = function(deckID, options) {
			var defaults = {
					loadCards: true,
					loadCardForecast: false,
					upcomingLoadedCallback: false,
					forceReview: false
				},
				
				today         = new Date(),
				dayConversion = 1000 * 60 * 60 * 24,
				timeDifference,
				upcomingCardCount,
				closestDate = false, // Used to determine the closest review date to today
				
				storedData = amplify.store(deckID),
				
				data = {
					id:    deckID,
					deck:  {},
					cards: {
						count:      0,
						studyCount: 0,
						allStudied: false,
					}
				},
				
				dataArray,
				deckString,
				cardString;
			
			options = $.extend(defaults, options);
			
			if (options.loadCardForecast) {
				data.cards.forecast = {
					studied:  [],
					review:   [],
					upcoming: []
				};
			}
			
			// @TODO Oh boy what a mess this is...
			
			// If this deck has not been saved yet, return undefined
			if (storedData === undefined) {
				return undefined;
			}
			
			// Split the data string into an array of 3-character long strings starting after the fourth character (cards use 3 characters each, the deck uses the first 4)
			dataArray = storedData.substring(4).match(/[^]{3}/g);
			
			// Get the deck data
			deckString = storedData.substr(0, 4);
			
			// First character is the date
			data.deck.lastStudyDate = unpackDate(deckString.charAt(0));
			
			// The first 9 bits of the second character are the number of cards per session, the last 7 bits are the time limit
			data.deck.cardsPerSession = extractBits(deckString.charCodeAt(1), 16, 8);
			data.deck.timeLimit       = extractBits(deckString.charCodeAt(1), 7, 1);
			
			// The first 13 bits of the third character are the randomize seed, the last 3 bits are booleans
			data.deck.randomizeSeed = extractBits(deckString.charCodeAt(2), 16, 4);
			data.deck.reversed      = !!extractBits(deckString.charCodeAt(2), 3, 3);
			data.deck.randomize     = !!extractBits(deckString.charCodeAt(2), 2, 2);
			data.deck.useTime       = !!extractBits(deckString.charCodeAt(2), 1, 1);
			data.deck.timesStudiedToday = extractBits(deckString.charCodeAt(3), 16, 1);
			
			// Generate a string dictating the last time this deck was studied
			if (isToday(data.deck.lastStudyDate)) {
				data.deck.lastStudied = 'today';
			} else {
				data.deck.lastStudied = 'past';
				data.deck.timesStudiedToday = 0;
			}
			
			
			upcomingCardCount = data.deck.cardsPerSession; // The number of upcoming cards (used for determining which unstudied cards are coming up)
			
			// Unpack cards
			if (options.loadCards) {
				for (var i = 1, len = dataArray.length+1; i < len; i++) {
					cardString = dataArray[i-1];
					
					data.cards[i] = {
						// First character is the date
						reviewDate: unpackDate(cardString.charAt(0)),
						
						// The first 14 bits of the second character are the delay factor, the last 2 bits are booleans
						delayFactor:    extractBits(cardString.charCodeAt(1), 16, 3),
						reverseStudied: !!extractBits(cardString.charCodeAt(1), 2, 2),
						studied:        !!extractBits(cardString.charCodeAt(1), 1, 1),
						
						// The last character is the delay factor for the reversed card
						reverseDelayFactor: extractBits(cardString.charCodeAt(2), 16, 1)
					};
					
					data.cards.count++; // Increment the number of cards in this deck
					
					// If this card has been studied, increment the number of studied cards
					if (data.cards[i].studied) {
						data.cards.studyCount++;
					}
					
					
					// Update the card forecast with this card
					if (options.loadCardForecast) {
						// If the closest review date to today hasn't been set, initialize it
						if (!closestDate) {
							closestDate = data.cards[i].reviewDate;
						} else if (closestDate > data.cards[i].reviewDate) {
							closestDate = data.cards[i].reviewDate;
						}
						
						// If this card has been studied, check if it's upcoming or needs to be reviewed
						if (data.cards[i].studied) {
							timeDifference = (data.cards[i].reviewDate - today) / dayConversion; // Convert to days
							
							data.cards.forecast.studied.push(i); // Add this card's id to the list of studied cards
							
							// If its review date is today or in the past
							if (timeDifference <= data.deck.timesStudiedToday - 1) {
								data.cards.forecast.review.push(i);
							// If it's review date is one day from now
							} else if (timeDifference <= data.deck.timesStudiedToday) {
								data.cards.forecast.upcoming.push(i);
							}
						} else {
							// If the order isn't randomized and we should have unstudied cards coming up
							if (!data.deck.randomize && upcomingCardCount) {
								upcomingCardCount--; // This one's going to be added
								
								data.cards.forecast.upcoming.push(i); // Add this card to the forecast of upcoming cards
							}
						}
					}
				}
				
				// Determine whether all cards have been studied
				if (data.cards.studyCount === data.cards.count) {
					data.cards.allStudied = true;
				}
				
				// @TODO Support for changelogs
				
				// Determine which cards are upcoming that have not been studied yet if the deck is in random order
				if (options.loadCardForecast && data.deck.randomize && data.cards.count !== data.cards.studyCount) {
					$.getJSON('/decks/'+deckID+'/cards/', {
						total:   data.deck.cardsPerSession,
						studied: encodeNumericArray(data.cards.forecast.studied),
						randomize:     data.deck.randomize,
						randomizeSeed: data.deck.randomizeSeed
					}, function(cardsData) {
						// Set the upcoming card ids based on the data we got back
						$.each(cardsData, function(i, cardData) {
							data.cards.forecast.upcoming.push(cardData[0]);
						});
						
						// Run the callback for when upcoming card data is available
						if (options.upcomingLoadedCallback) {
							options.upcomingLoadedCallback(data);
						}
					});
				} else if (options.upcomingLoadedCallback) {
					// Run the callback for when upcoming card data is available
					options.upcomingLoadedCallback(data);
				}
				
				// If the user studied today and there are no review cards in the immediate future, find the closest review cards to today
				if ((data.deck.timesStudiedToday || options.forceReview) && data.cards.allStudied && options.loadCardForecast && !data.cards.forecast.review.length) {
					for (var i = 1, len = dataArray.length+1; i < len; i++) {
						if (data.cards[i].reviewDate.getTime() == closestDate.getTime()) {
							data.cards.forecast.review.push(i);
						}
					}
				}
			}
			
			return data;
		},
		
		
		
		/**
		* Initializes deck data for storage on the client side.
		* @return object An object representing the deck data.
		*/
		initializeDeckData = function() {
			var now = new Date(),
				dataField,
				deckData = {
					// The last time this deck was studied (initially a month in the past to prevent possible issues)
					lastStudyDate: 0,
					
					// Default values
					cardsPerSession: 20,
					timeLimit: 10,
					reversed: 0,
					randomize: 0,
					useTime: 0,
					randomizeSeed: Math.max(Math.floor(Math.random() * (Math.pow(2, 13))), 1), // Random number between 1 and 2^13 - 1
					timesStudiedToday: 0
				};
			
			now.setMonth(now.getMonth() - 1);
			deckData.lastStudyDate = now;
			
			// Check if a card-count or last-item field exists to determine the number of cards to study per session
			// All other fields we need should be present if one of these fields is
			dataField = $('input[name=cards-per-session], input[name=last-item]');
			if (dataField.length) {
				deckData.cardsPerSession = parseInt(dataField.val(), 10);
				
				// Get the time limit
				deckData.timeLimit = parseInt($('input[name=time-limit]').val(), 10);
				
				// Determine whether to use the reversed side
				
				dataField = $('input[name=use-reverse]');
				deckData.reversed = dataField.val();
				
				// Account for checkboxes, in case this field is not a typical input field
				if (deckData.reversed === 'on') {
					deckData.reversed = dataField.is(':checked');
				} else {
					deckData.reversed = !!deckData.reversed
				}
				
				
				// Determine whether to randomize the order
				
				dataField = $('input[name=randomize]');
				deckData.randomize = dataField.val();
				
				// Account for checkboxes, in case this field is not a typical input field
				if (deckData.randomize === 'on') {
					deckData.randomize = dataField.is(':checked');
				} else {
					deckData.randomize = !!deckData.randomize
				}
				
				
				// Determine whether to use a time limit
				
				dataField = $('input[name=use-time]');
				deckData.useTime = dataField.val();
				
				// Account for checkboxes, in case this field is not a typical input field
				if (deckData.useTime === 'on') {
					deckData.useTime = dataField.is(':checked');
				} else {
					deckData.useTime = !!deckData.useTime
				}
			}
			
			return deckData;
		}
		
		/**
		* Initializes card data for storage on the client side.
		* @param int cardCount The number of cards in the deck.
		* @return object An object in the format {orderInDeck: {cardDataField: cardData}, ...}
		*/
		initializeCardData = function(cardCount) {
			var cardData = {};
			
			for (var i = 1; i <= cardCount; i++) {
				cardData[i] = {
					// When to review the card
					reviewDate: new Date(),
					
					// Delay factor for setting the next review date for the card
					delayFactor:        0,
					reverseDelayFactor: 0,
					
					// Whether the card and its reversed side have been studied
					studied:        false,
					reverseStudied: false
				};
			}
			
			return cardData;
		},
		
		/**
		* Initializes progress data for storage on the client side.
		* @param int deckID The id of the deck to initialize storage for.
		* @param int cardCount The number of cards in the deck.
		* @return object The initialized progress data.
		*/
		initializeProgress = function(deckID, cardCount) {
			return {
				id:    deckID,
				deck:  initializeDeckData(),
				cards: initializeCardData(cardCount)
			};
		};
	
	
	// @TODO Any study buttons on the home and search page should be converted to forms by JS on click, to initialize the study interface appropriately
	
	
	// Animate the background image in if we're on the home page
	if (body.hasClass('home-page')) {
		anime.showMural();
	}
	
	// Remove the initial class after 2 seconds
	setTimeout(function() { body.removeClass('initial'); }, 2000);
	
	// @TODO Why do I do this?
	//History.replaceState({home: true}, '', window.location);
	
	$(window).on('statechange', function() {
		var State = History.getState();
		
		// @TODO We need a loader for while content is coming in (only if it hasn't come in after a short delay)
		$.ajax({
			url: State.url,
			type: State.data.method || 'GET', // Defaults to GET
			data: State.data,
			success: function(response) {
				var title,
					scripts = $(response).filter('script'); // @TODO There are 3 scripts that will always show up here... we could optimize
				
				response = $(response).not('script'); // Prevent scripts from being executed early
				title = response.filter('title').text();
				
				document.title = title;
				anime.transitionPageTo(response.filter('#wrap'), response.filter('#toolbar'), response.filter('#footer'), scripts, State.data);
			}
		});
	});
	
	
	
	// If the user clicks a study button anchor and they have progress saved, convert it to a form to preserve their settings
	if (storageSet) {
		body.on('click', 'a.study-btn', function(e) {
			var button   = $(this),
				progress = loadProgress(button.attr('data-deck-id')),
				deck,
				dataForm;
			
			// Only do anything if the user has progress saved for this deck
			if (progress) {
				e.preventDefault();
				
				deck = progress.deck;
				dataForm = $('<form method="POST" />').attr(
								'action', button.attr('href')
							).append(
								$('<input name="cards-per-session" value="'+deck.cardsPerSession+'" />')
							).append(
								$('<input type="checkbox" name="use-time" />').prop('checked', deck.useTime)
							).append(
								$('<input name="time-limit" value="'+deck.timeLimit+'" />')
							).append(
								$('<input type="checkbox" name="randomize" />').prop('checked', deck.randomize)
							).append(
								$('<input type="checkbox" name="use-reverse" />').prop('checked', deck.reversed)
							).append(
								$('<input name="randomize-seed" value="'+deck.randomizeSeed+'" />')
							).append(
								$('input[name=csrfmiddlewaretoken]').clone()
							).hide().appendTo(
								body
							).submit();
			}
		});
	}
	
	
	
	
	body.on('click', '.page-transition-button', function(e) {
		e.preventDefault();
		
		var that = $(this),
			data = {
				home: that.hasClass('home-link')
			};
		
		History.pushState(data, '', that.attr('href'));
	});
	
	
	body.on('submit', '.page-transition-form', function(e) {
		e.preventDefault();
		
		var that = $(this),
			method = that.attr('method').toLowerCase(),
			fields = that.find('input, textarea'),
			formData;
		
		// GET request
		if (method === 'get') {
			formData = '';
			
			// @TODO Use jQuery.serialize() on the form to get the query string
			fields.each(function(index, field) {
				field = $(field);
				
				if (field.attr('name') !== undefined) {
					formData += field.attr('name')+'='+encodeURIComponent(field.val());
				}
			});
			
			History.pushState(null, '', that.attr('action')+'?'+formData);
		// POST request
		} else if (method === 'post') {
			// @TODO This is totally broken
			formData = {method: 'POST'};
			
			fields.each(function(index, field) {
				field = $(field);
				
				// @TODO Use jQuery.serialize() on the form to get the query string
				if (field.attr('name') !== undefined) {
					if (field.attr('type') === 'checkbox') {
						// Checkboxes must have their value checked in this way
						if (field.is(':checked')) {
							formData[field.attr('name')] = true;
						}
					} else {
						formData[field.attr('name')] = field.val();
					}
				}
			});
			
			History.pushState(formData, '', that.attr('action'));
		}
	});
	
	
	
	return {
		// Properties
		storageSet: storageSet,
		
		
		// Methods
		isToday:            isToday,
		encodeNumericArray: encodeNumericArray,
		
		initializeProgress: initializeProgress,
		saveProgress: saveProgress,
		loadProgress: loadProgress
	};
}(jQuery));
