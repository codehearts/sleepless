// @codekit-prepend "json2.js"
// @codekit-prepend "amplify.store.min.js"
// @codekit-prepend "jquery.history.js"

// @codekit-prepend "classes.js"
// @codekit-prepend "anime.js"
// @codekit-prepend "jquery.inview.js"

// @codekit-append "launch.js"
// @codekit-append "study.js"



var Sleepless = (function($) {
	var body = $(document.body),
		
		yearOffset = 2012, // Our client-side date storing algorithm will only work for 127 years after this date
		
		storageSet = ! $.isEmptyObject(amplify.store()),
		
		History = window.History,
		
		
		
		
		
		boolToInt = function(bool) {
			return bool ? 1 : 0;
		},
		
		// Storage Methods
		
		/**
		* Packs the given values into a single character generated by the values' 16-bit binary representation.
		*
		* @param mixed values The values to pack in the format [val, bits], [val, bits], ... where the bits total up to 16. The first argument's binary representation will be on the lefthand side of the final binary representation.
		* @return string A single character generated from the 16-bit binary representation of the given values.
		*/
		pack = function() {
			var lastArgumentIndex = arguments.length - 1,
				len = arguments.length,
				i   = 0,
				binary;
			
			for (; i < len; i++) {
				if (i === lastArgumentIndex) {
					binary = binary | arguments[i][0];
				} else if (i > 0) {
					binary = (binary | arguments[i][0]) << arguments[i+1][1];
				} else {
					binary = arguments[i][0] << arguments[i+1][1];
				}
			}
			
			return String.fromCharCode(binary);
		},
		
		/**
		* Extracts bits from the given binary value from upperBit to lowerBit.
		* @param int binary The binary value to extract bits from.
		* @param int upperBit The rightmost bit to extract.
		* @param int lowerBit The leftmost bit to extract.
		* @return int The extracted bits.
		*/
		extractBits = function (binary, upperBit, lowerBit) {
			upperMask = (1 << upperBit) - 1;
			lowerMask = (1 << (lowerBit - 1)) - 1;
	 		
			return (binary & (upperMask ^ lowerMask)) >> (lowerBit - 1);
		},
		
		
		
		/**
		* Packs the given Date object into a single character.
		* @param Date date The date to pack.
		* @return string The packed date character.
		*/
		packDate = function(date) {
			var year  = date.getFullYear() - yearOffset,
				month = date.getMonth(),
				day   = date.getDate();
			
			// 4 bits for months, 5 bits for days, 7 bits for years
			return pack([month, 4], [day, 5], [year, 7]);
		},
		
		/**
		* Unpacks the given character into a Date object.
		* @param string character The character to unpack into a date.
		* @return Date The Date object represented by that character.
		*/
		unpackDate = function(date) {
			var charCode = date.charCodeAt(0),
				month = extractBits(charCode, 16, 13),
				day   = extractBits(charCode, 12, 8),
				year  = extractBits(charCode, 7, 1) + yearOffset;
			// 4 bits for months, 5 bits for days, 7 bits for years
			
			return new Date(year, month, day);
		}
		
		
		
		/**
		* Saves the deck data into client-side storage.
		* @param int id The id of the deck.
		* @param object data The data to save.
		*/
		saveProgress = function(data) {
			var deck  = data.deck,
				cards = data.cards,
				deckString = '',
				cardString = '',
				card_id,
				card;
			
			// First 3 characters are deck data
			deckString  = packDate(deck.lastStudyDate);
			deckString += pack(
				[Math.min(Math.max(deck.cardsPerSession, 0), 500), 9], // limit 500
				[Math.min(Math.max(deck.timeLimit, 0), 120), 7] // Limit 120
			);
			deckString += pack(
				[Math.min(Math.max(deck.randomizeSeed, 0), Math.pow(2, 13)-1), 13], // Limit 2^13 - 1
				[boolToInt(deck.reversed), 1],
				[boolToInt(deck.randomize), 1],
				[boolToInt(deck.useTime), 1]
			);
			
			for (card_id in cards) {
				if (cards.hasOwnProperty(card_id) && $.isNumeric(card_id)) {
					card = cards[card_id];
					
					// Each card's data requires 3 characters
					cardString += packDate(card.reviewDate);
					cardString += pack(
						[Math.min(Math.max(card.delayFactor, 0), Math.pow(2, 14) - 1), 14], // Limit 2^14 - 1
						[boolToInt(card.reverseStudied), 1],
						[boolToInt(card.studied), 1]
					);
					cardString += pack([Math.min(Math.max(card.reverseDelayFactor, 0), Math.pow(2, 16)-1), 16]); // Limit 2^16 - 1
				}
			}
			
			amplify.store(data.id, deckString+cardString);
		},
		
		/**
		* Loads the deck data from client-side storage, or returns undefined if the deck was never saved.
		* @param int deckID The id of the deck to load data for.
		* @param object options Optiosn that determine how much data will be processed and returned. Possible options are loadCards and loadCardForecast. The last one will add an extra property to the returned object, data.cards.forecast, which contain these arrays of card IDs: review, upcoming.
		* @return object The loaded data in the format {id: deckID, deck: {deckDataField: deckData, ...}, cards: {order: {cardDataField: cardData, ...}}}. data.cards also contains a studyCount property with the number of cards studied.
		*/
		loadProgress = function(deckID, options) {
			var defaults = {
					loadCards: true,
					loadCardForecast: false
				},
				
				today         = new Date(),
				dayConversion = 1000 / 60 / 60 / 24,
				timeDifference,
				
				storedData = amplify.store(deckID),
				
				data = {
					id:    deckID,
					deck:  {},
					cards: {
						studyCount: 0
					}
				},
				
				dataArray,
				deckString,
				cardString;
			
			options = $.extend(defaults, options);
			
			if (options.loadCardForecast) {
				data.cards.forecast = {
					review:  [],
					upcoming: []
				};
			}
			
			// @TODO Oh boy what a mess this is...
			
			// If this deck has not been saved yet, return undefined
			if (storedData === undefined) {
				return undefined;
			}
			
			// Split the data string into an array of 3-character long strings (all stored item use 3 characters each)
			dataArray = storedData.match(/.{3}/g);
			
			// Get the deck data
			deckString = dataArray.shift();
			
			// First character is the date
			data.deck.lastStudyDate = unpackDate(deckString.charAt(0));
			
			// The first 9 bits of the second character are the number of cards per session, the last 7 bits are the time limit
			data.deck.cardsPerSession = extractBits(deckString.charCodeAt(1), 16, 8);
			data.deck.timeLimit       = extractBits(deckString.charCodeAt(1), 7, 1);
			
			// The first 13 bits of the third character are the randomize seed, the last 3 bits are booleans
			data.deck.randomizeSeed = extractBits(deckString.charCodeAt(2), 16, 4);
			data.deck.reversed      = !!extractBits(deckString.charCodeAt(2), 3, 3);
			data.deck.randomize     = !!extractBits(deckString.charCodeAt(2), 2, 2);
			data.deck.useTime       = !!extractBits(deckString.charCodeAt(2), 1, 1);
			
			// Unpack cards
			for (var i = 1, len = dataArray.length+1; i < len; i++) {
				cardString = dataArray[i-1];
				
				data.cards[i] = {
					// First character is the date
					reviewDate: unpackDate(cardString.charAt(0)),
					
					// The first 14 bits of the second character are the delay factor, the last 2 bits are booleans
					delayFactor:    extractBits(cardString.charCodeAt(1), 16, 3),
					reverseStudied: !!extractBits(cardString.charCodeAt(1), 2, 2),
					studied:        !!extractBits(cardString.charCodeAt(1), 1, 1),
					
					// The last character is the delay factor for the reversed card
					reverseDelayFactor: extractBits(cardString.charCodeAt(2), 16, 1)
				};
				
				// If this card has been studied, increment the number of studied cards
				if (data.cards[i].studied) {
					data.cards.studyCount++;
				}
				
				// @TODO This doesn't handle reversed cards
				// If we need to load the card forecast and this card has been studied, check if it's upcoming or needs to be reviewed
				if (options.loadCardForecast && data.cards[i].studied) {
					timeDifference = (data.cards[i].reviewDate - today) / dayConversion; // Convert to days
					
					// If its review date is today or in the past
					if (timeDifference <= 1) {
						data.cards.forecast.review.push(i);
					// If it's review date is one day from now
					} else if (timeDifference > 1 && timeDiffernece < 2) {
						data.cards.forecast.upcoming.push(i);
					}
				}
			}
			
			return data;
		},
		
		
		
		/**
		* Initializes deck data for storage on the client side.
		* @return object An object representing the deck data.
		*/
		initializeDeckData = function() {
			var now = new Date(),
				dataField,
				deckData = {
					// @TODO We only need to do this for the first deck ever stored, though.
					// The last time this deck was studied (initially a month in the past to prevent possible issues)
					lastStudyDate: 0,
					
					// Default values
					cardsPerSession: 20,
					timeLimit: 10,
					reversed: 0,
					randomize: 0,
					useTime: 0,
					randomizeSeed: Math.floor(Math.random() * (Math.pow(2, 13))) // Random number between 0 and 2^13 - 1
				};
			
			now.setMonth(now.getMonth() - 1);
			deckData.lastStudyDate = now;
			
			// Check if a card-count or last-item field exists to determine the number of cards to study per session
			// All other fields we need should be present if one of these fields is
			dataField = $('input[name=cards-per-session], input[name=last-item]');
			if (dataField.length) {
				deckData.cardsPerSession = parseInt(dataField.val(), 10);
				
				// Get the time limit
				deckData.timeLimit = parseInt($('input[name=time-limit]').val(), 10);
				
				// Determine whether to use the reversed side
				
				dataField = $('input[name=use-reverse]');
				deckData.reversed = dataField.val();
				
				// Account for checkboxes, in case this field is not a typical input field
				if (deckData.reversed === 'on') {
					deckData.reversed = dataField.is(':checked');
				} else {
					deckData.reversed = !!deckData.reversed
				}
				
				
				// Determine whether to randomize the order
				
				dataField = $('input[name=randomize]');
				deckData.randomize = dataField.val();
				
				// Account for checkboxes, in case this field is not a typical input field
				if (deckData.randomize === 'on') {
					deckData.randomize = dataField.is(':checked');
				} else {
					deckData.randomize = !!deckData.randomize
				}
				
				
				// Determine whether to use a time limit
				
				dataField = $('input[name=use-time]');
				deckData.useTime = dataField.val();
				
				// Account for checkboxes, in case this field is not a typical input field
				if (deckData.useTime === 'on') {
					deckData.useTime = dataField.is(':checked');
				} else {
					deckData.useTime = !!deckData.useTime
				}
			}
			
			return deckData;
		}
		
		/**
		* Initializes card data for storage on the client side.
		* @param int cardCount The number of cards in the deck.
		* @return object An object in the format {orderInDeck: {cardDataField: cardData}, ...}
		*/
		initializeCardData = function(cardCount) {
			var cardData = {};
			
			for (var i = 1; i <= cardCount; i++) {
				cardData[i] = {
					// When to review the card
					reviewDate: new Date(),
					
					// Delay factor for setting the next review date for the card
					delayFactor:        0,
					reverseDelayFactor: 0,
					
					// Whether the card and its reversed side have been studied
					studied:        false,
					reverseStudied: false
				};
			}
			
			return cardData;
		},
		
		/**
		* Initializes progress data for storage on the client side.
		* @param int deckID The id of the deck to initialize storage for.
		* @param int cardCount The number of cards in the deck.
		* @return object The initialized progress data.
		*/
		initializeProgress = function(deckID, cardCount) {
			return {
				id:    deckID,
				deck:  initializeDeckData(),
				cards: initializeCardData(cardCount)
			};
		};
	
	
	// @TODO Any study buttons on the home and search page should be converted to forms by JS on click, to initialize the study interface appropriately
	
	
	// Animate the background image in if we're on the home page
	if (body.hasClass('home-page')) {
		anime.showMural();
	}
	
	// Remove the initial class after 2 seconds
	setTimeout(function() { body.removeClass('initial'); }, 2000);
	
	// @TODO Why do I do this?
	//History.replaceState({home: true}, '', window.location);
	
	$(window).on('statechange', function() {
		var State = History.getState();
		
		// @TODO We need a loader for while content is coming in (only if it hasn't come in after a short delay)
		$.ajax({
			url: State.url,
			type: State.data.method || 'GET', // Defaults to GET
			data: State.data,
			success: function(response) {
				var title,
					scripts = $(response).filter('script'); // @TODO There are 3 scripts that will always show up here... we could optimize
				
				response = $(response).not('script'); // Prevent scripts from being executed early
				title = response.filter('title').text();
				
				document.title = title;
				anime.transitionPageTo(response.filter('#wrap'), response.filter('#toolbar'), response.filter('#footer'), scripts, State.data);
			}
		});
	});
	
	
	body.on('click', '.page-transition-button', function(e) {
		e.preventDefault();
		
		var that = $(this),
			data = {
				home: that.hasClass('home-link')
			};
		
		History.pushState(data, '', that.attr('href'));
	});
	
	
	body.on('submit', '.page-transition-form', function(e) {
		e.preventDefault();
		
		var that = $(this),
			method = that.attr('method').toLowerCase(),
			fields = that.find('input, textarea'),
			formData;
		
		// GET request
		if (method === 'get') {
			formData = '';
			
			// @TODO Use jQuery.serialize() on the form to get the query string
			fields.each(function(index, field) {
				field = $(field);
				
				if (field.attr('name') !== undefined) {
					formData += field.attr('name')+'='+encodeURIComponent(field.val());
				}
			});
			
			History.pushState(null, '', that.attr('action')+'?'+formData);
		// POST request
		} else if (method === 'post') {
			// @TODO This is totally broken
			formData = {method: 'POST'};
			
			fields.each(function(index, field) {
				field = $(field);
				
				// @TODO Use jQuery.serialize() on the form to get the query string
				if (field.attr('name') !== undefined) {
					if (field.attr('type') === 'checkbox') {
						// Checkboxes must have their value checked in this way
						if (field.is(':checked')) {
							formData[field.attr('name')] = true;
						}
					} else {
						formData[field.attr('name')] = field.val();
					}
				}
			});
			
			History.pushState(formData, '', that.attr('action'));
		}
	});
	
	
	
	return {
		// Properties
		storageSet: storageSet,
		
		// Methods
		initializeProgress: initializeProgress,
		saveProgress: saveProgress,
		loadProgress: loadProgress
	};
}(jQuery));